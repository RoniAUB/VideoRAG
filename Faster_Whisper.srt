1
00:00:00,000 --> 00:00:08,000
So, hello, everyone. Welcome to the PC Seminar. Today, we have this Professor Amir Mohad

2
00:00:08,000 --> 00:00:12,640
from American University of Beirut, and he'll be talking on the girth and parametrious

3
00:00:12,640 --> 00:00:17,280
complexity of token sliding and token jumping. Thank you for joining us, Professor.

4
00:00:17,280 --> 00:00:23,280
Over to you now. Thank you, President. Thank you for having me. It's a real pleasure

5
00:00:23,280 --> 00:00:31,520
to be here. So, all right, let's jump right into it. So, since I did not really know

6
00:00:31,520 --> 00:00:38,880
the audience too well, I made the assumption that many of you maybe have not seen this area

7
00:00:38,880 --> 00:00:45,120
of combinatorial reconfiguration problems. So, I decided what I'm going to do is I'm going

8
00:00:45,120 --> 00:00:50,400
to give a gentle introduction to the area just to show you how many exciting problems

9
00:00:50,400 --> 00:00:57,280
and open problems are there. And then I will talk more about token jumping and token sliding,

10
00:00:57,280 --> 00:01:02,800
specifically what we know about them, what we knew about them before we started working on this

11
00:01:02,800 --> 00:01:09,360
project, what we managed to discover and the tons of questions that remain to be answered.

12
00:01:10,080 --> 00:01:17,200
Right? And it's a really, I mean, the questions are so nice to state, so easy to state, and they

13
00:01:17,360 --> 00:01:24,320
are accessible really to researchers at any level, which is one of the reasons why I enjoy working on

14
00:01:24,320 --> 00:01:32,080
these problems. So, so hopefully you'll get to enjoy them too. So, before I start, I should point

15
00:01:32,080 --> 00:01:38,400
out that this is joint work that started back in the combinatorial reconfiguration workshop

16
00:01:39,440 --> 00:01:46,320
almost two years ago. And it's joint work with Valentine BarchÃ©, Nicolas Busque, Le Mandalard,

17
00:01:46,320 --> 00:01:56,160
and Karl Lomer, who is my master's student. All right. So, the outline of the talk, it's

18
00:01:56,160 --> 00:02:02,320
going to be in four sections. I will give a gentle introduction to combinatorial reconfiguration,

19
00:02:02,320 --> 00:02:11,040
because I know many of you might not have seen such problems. Then I will talk about token jumping

20
00:02:11,040 --> 00:02:16,720
and token sliding, what we know about them in terms of classical complexity or one-dimensional

21
00:02:16,720 --> 00:02:23,040
complexity. Then I'll talk about the parameterous complexity of these two problems and what we know

22
00:02:23,040 --> 00:02:30,240
as of today, as we speak. And what are the problems that remain to be solved? And then the last part of

23
00:02:30,240 --> 00:02:34,720
the lecture is where I will put some of the technical stuff to show you to give you an idea

24
00:02:35,520 --> 00:02:40,640
about how we prove things when we deal with such problems and where are the difficulties

25
00:02:40,640 --> 00:02:46,720
and what kind of techniques have been developed. So, I tried to keep the technical part as light as

26
00:02:46,720 --> 00:02:54,880
I could so that really, I mean, I can focus on the big picture and the questions to be asked

27
00:02:54,880 --> 00:02:59,840
and answered. So, if you have any questions along the way, please feel free to interrupt me

28
00:02:59,840 --> 00:03:07,840
either in the chat or by unmuting yourselves. So, don't worry about leaving the questions

29
00:03:07,840 --> 00:03:11,840
till the end. You can interrupt me whenever you feel, whenever I say something that doesn't make

30
00:03:11,840 --> 00:03:19,760
sense. Hopefully that won't happen too often. All right, so what is combinatorial reconfiguration?

31
00:03:19,760 --> 00:03:26,240
So, the best way I think to introduce is with a familiar example, which is one player games,

32
00:03:26,240 --> 00:03:32,640
and the most common one that we use is the 15 puzzle game. So, for those of you who don't know

33
00:03:32,720 --> 00:03:39,040
the 15 puzzle game, so you're given like a four by four grid, and you have one empty square.

34
00:03:40,240 --> 00:03:45,520
And basically, you have all the remaining 15 squares are numbered from one to 15, and they come in

35
00:03:45,520 --> 00:03:52,320
some ordering. And your job is to basically move the squares around so that all the numbers become

36
00:03:52,320 --> 00:03:58,560
ordered. So, it's a vital. So, they have to be ordered this way. So, if you notice in this

37
00:03:58,560 --> 00:04:05,200
figure, the only problem is that 14 and 15 are reversed, but the only moves that you're allowed to

38
00:04:05,200 --> 00:04:13,600
do is to basically move a number into the empty square. And basically, you have to do a sequence of

39
00:04:13,600 --> 00:04:20,720
moves so that you get all of the numbers in order. And for those of you who know this game,

40
00:04:20,720 --> 00:04:28,080
this example that I have on the slide is actually unsolved. There is no way you can flip the order

41
00:04:28,080 --> 00:04:34,320
and 15 of 14 and 15 in this puzzle. And I have a link here if you want to actually play the

42
00:04:34,320 --> 00:04:41,920
puzzle online, which is pretty fun. So, why do I start my talk by talking about 15 puzzle? It's

43
00:04:41,920 --> 00:04:48,800
because it's really, I mean, the way you solve the 15 puzzle tells you a lot about the area of

44
00:04:48,800 --> 00:04:56,080
combinatorial reconfiguration. So, the standard way we would think about the 15 puzzle is by looking

45
00:04:56,080 --> 00:05:02,160
at the state space or what we call the reconfiguration graph of the 15 puzzle. So, what does that

46
00:05:02,160 --> 00:05:10,000
graph consist of? Well, we have one vertex or one node in this graph for each possible configuration

47
00:05:10,000 --> 00:05:16,080
of the puzzle. So, basically, each possible configuration, so it would be a possible permutation

48
00:05:16,080 --> 00:05:22,080
of the 15 numbers. In addition to where you're going to put the empty square, each one of those

49
00:05:22,080 --> 00:05:29,680
will be a vertex in the graph. And now, we connect two vertices in that graph whenever one can

50
00:05:29,680 --> 00:05:35,200
be reached from the other by a single move. And what do we mean here by a single move where it's

51
00:05:35,200 --> 00:05:43,280
basically just moving number into the empty square. So, if you look at the top node here in this graph,

52
00:05:43,280 --> 00:05:48,960
there are four possibilities that you can do in one move, which we call a reconfiguration step,

53
00:05:48,960 --> 00:05:53,840
which is you can move nine into the empty square, you can move three into the empty square,

54
00:05:54,560 --> 00:06:00,320
12 or 15. And that gives us basically four neighbors of that vertex in the graph.

55
00:06:01,680 --> 00:06:07,440
Okay, and we call this whole graph the reconfiguration graph or the state space if you're more

56
00:06:07,440 --> 00:06:15,440
comfortable thinking about states, the states of the game. So, now given this graph, the reconfiguration

57
00:06:15,920 --> 00:06:21,200
graph, there are tons of very interesting questions that you can ask about it. There are structural

58
00:06:21,200 --> 00:06:27,120
questions and there are algorithmic questions. And these are typically the types of questions that

59
00:06:27,120 --> 00:06:35,600
we're interested in in this area of combinatorially configuration. So, a couple of examples of structural

60
00:06:35,600 --> 00:06:41,040
questions would be, well, the simplest one would be how big is this reconfiguration graph,

61
00:06:41,040 --> 00:06:48,480
right? How many vertices or how many edges? And that's usually not a very hard question to answer

62
00:06:48,480 --> 00:06:54,560
in terms of upper and lower ones. More interestingly, you can ask, is this reconfiguration graph

63
00:06:54,560 --> 00:07:02,000
connected, right? Or is, can I reach any state starting from any other state by a sequence of legal

64
00:07:02,000 --> 00:07:09,760
moves? And as I told you before, for the 15 puzzle, the reconfiguration graph is definitely not connected,

65
00:07:09,760 --> 00:07:15,360
because there was no way to reverse 14 and 15 in the previous example that I showed you and you

66
00:07:15,360 --> 00:07:20,880
can easily prove that, by the way. So, when it's not connected, another question would be how many

67
00:07:20,880 --> 00:07:28,800
components does I have? Is there some sort of a nice structure to the components of this graph?

68
00:07:30,000 --> 00:07:35,200
And then another question would be, what is the diameter of this reconfiguration graph or of

69
00:07:35,360 --> 00:07:39,680
each one of its components? And that's usually a very important question to ask when you're dealing with

70
00:07:39,680 --> 00:07:46,880
one player games, because this could tell you, like, what would be the worst possible shortest path

71
00:07:46,880 --> 00:07:52,480
to reach a target configuration or to solve your game, to win your game, for example. And in

72
00:07:52,480 --> 00:07:58,320
the literature, this is sometimes known as God's number, which would be the diameter of the

73
00:07:58,320 --> 00:08:04,640
reconfiguration graph. And these are all very interesting, very interesting structural questions to

74
00:08:04,640 --> 00:08:11,680
ask about this reconfiguration graph. Now, on the algorithmic side or the computational side,

75
00:08:11,680 --> 00:08:18,320
there's the obvious question of if I'm given a starting state and some ending state or target state,

76
00:08:18,320 --> 00:08:23,520
like in the case of the puzzle game, that I am given some starting state and we know what the

77
00:08:23,520 --> 00:08:29,360
goal state is. So here one decision problem would be to answer the question whether it's possible

78
00:08:29,360 --> 00:08:34,320
to get to the target state starting from some initial state that is also given to me.

79
00:08:35,840 --> 00:08:40,320
So you can decide to solve this problem either as a decision problem or as a search problem,

80
00:08:40,320 --> 00:08:45,920
which would give you the actual sequence of steps that will take you from a state to the target state.

81
00:08:46,880 --> 00:08:55,520
Other interesting computational problems, is it always possible to go from one configuration to

82
00:08:55,520 --> 00:09:01,200
any other? And this is basically also related to the structural question about connected components.

83
00:09:02,400 --> 00:09:09,280
And the last question that I will mention, which is also interesting, is how fast can you go from

84
00:09:09,280 --> 00:09:13,680
one configuration to another? Meaning can you do it in at most case steps?

85
00:09:16,480 --> 00:09:20,400
There is a question I should wait or no.

86
00:09:25,280 --> 00:09:34,000
All right. So think about all of these questions that we paused using the simple 15 puzzle game.

87
00:09:34,080 --> 00:09:40,160
And now we're going to look at a lot of other possible problems where the same

88
00:09:40,160 --> 00:09:45,840
any configuration graph can be extracted. And we can ask the same set of questions.

89
00:09:46,800 --> 00:09:52,400
So all of you here are familiar with the case sad problem. So you're given a Boolean formula and

90
00:09:52,400 --> 00:09:58,960
you want to know if you can satisfy this formula by assigning values to the variables. And we know

91
00:09:59,040 --> 00:10:04,880
that this is NP complete for K greater than or equal to three. So now how can you transform this

92
00:10:04,880 --> 00:10:10,000
into a reconfiguration problem? Well, it's very simple. So now you're given the formula

93
00:10:11,440 --> 00:10:16,720
and you're given two satisfying assignments. So you can think of those satisfying assignments as

94
00:10:16,720 --> 00:10:24,480
bit vectors. And so now the question that you can ask is can I go from the first satisfying assignment

95
00:10:24,480 --> 00:10:32,880
as to the next one? By basically flipping one bit at a time under the condition that I remain

96
00:10:32,880 --> 00:10:39,280
a satisfying assignment at all times. And notice that without this condition the problem is trivial.

97
00:10:40,960 --> 00:10:48,080
So you can basically just flip the bits however you like and reach S from T or T from S. But once

98
00:10:48,080 --> 00:10:54,160
you have this constraint of you should remain a satisfying assignment, the problem becomes

99
00:10:54,160 --> 00:11:00,080
way more interesting. And you can think of this problem again as walking in the solution space

100
00:11:00,880 --> 00:11:05,520
of the given formula of all the satisfying assignment of the formula F.

101
00:11:09,040 --> 00:11:14,560
Alright, so that's the sad reconfiguration problem. Let's look at another example.

102
00:11:14,720 --> 00:11:23,520
Graph coloring. We all know it. We all love it. You're given a graph and some integer K. And you are

103
00:11:23,520 --> 00:11:28,960
asked whether you can properly cave color the graph G. And we know again that this is NP complete

104
00:11:28,960 --> 00:11:34,160
for K greater than or equal to three. How do you transform that into a reconfiguration problem?

105
00:11:34,160 --> 00:11:41,120
Well, now you're given a graph. You're given two colorings of the graph, alpha and beta. And the

106
00:11:41,200 --> 00:11:49,200
question is can you recolor alpha to get the to beta. But you need to recolor one vertex at a time

107
00:11:49,200 --> 00:11:56,640
and you need to remain a proper K coloring throughout. Same idea again leads us to this notion

108
00:11:56,640 --> 00:12:02,640
of the reconfiguration space where we are looking at the K colorings of the graph and how they are

109
00:12:02,640 --> 00:12:09,200
connected under this adjacency relation that we define which is a single vertex recoloring.

110
00:12:11,920 --> 00:12:17,120
The final example that I will mention, which will be basically what we will focus on in the rest

111
00:12:17,120 --> 00:12:23,440
of the talk, is token placement. I call it, but as you will all guess, this is the famous independent

112
00:12:23,440 --> 00:12:29,360
set problem. But we will look at it as a token placement problem because it will be more useful

113
00:12:29,360 --> 00:12:34,240
for the rest of the talk. So you're given a graph G and an integer K. And the question is can

114
00:12:34,240 --> 00:12:40,720
you place K tokens on your graph K black tokens so that no two of these tokens share an edge.

115
00:12:40,720 --> 00:12:46,480
And of course, we all know that this is an NP complete problem. So how can you transform

116
00:12:46,480 --> 00:12:51,760
this problem into a reconfiguration problem? Again, now I'm giving a graph, two independent

117
00:12:51,760 --> 00:12:58,800
sets of the graph, each of size K. And the question is can I go from one independent set to the other

118
00:13:00,400 --> 00:13:07,520
under what rule? So here defining the rule for independent set, how can I go between consecutive

119
00:13:07,520 --> 00:13:14,160
independent sets becomes a little bit less obvious. And there are two main strategies that people

120
00:13:14,160 --> 00:13:20,880
have attempted. So the first rule is what we call token jumping. So you are basically allowed

121
00:13:20,880 --> 00:13:27,520
to take any token on your graph and jump it to any other vertex on the graph, assuming that it

122
00:13:27,520 --> 00:13:34,400
doesn't have a token and that you maintain an independent set at all times. So for example, in this

123
00:13:35,040 --> 00:13:41,120
example that I have here, it would be perfectly okay to take this token here and jump it to this

124
00:13:41,120 --> 00:13:51,600
vertex here. Or I could also take this token here and jump it to this vertex here. So that, no,

125
00:13:51,600 --> 00:13:57,840
actually that would violate the independence. So you can jump to any other vertex as long as you

126
00:13:57,840 --> 00:14:04,720
maintain independence. And we call that the token jumping rule. The other rule is basically token

127
00:14:04,720 --> 00:14:10,000
sliding. So in this case, we only allow a token to slide along edges of the graph.

128
00:14:11,440 --> 00:14:20,080
So a token can only move to adjacent vertex, assuming of course, this does not violate independence.

129
00:14:20,880 --> 00:14:25,680
So now we have two different reconfiguration graphs we can think about. We can think about the

130
00:14:25,680 --> 00:14:31,280
reconfiguration graph under the token jumping adjacency. And we can think about the reconfiguration

131
00:14:31,280 --> 00:14:37,760
graph under the token sliding adjacency. And we're going to talk about these two different problems

132
00:14:37,760 --> 00:14:44,080
because they do actually behave quite differently. And they produce quite interesting results,

133
00:14:44,080 --> 00:14:49,280
like the difference between the two. We don't fully understand yet, but we kind of know that token

134
00:14:49,280 --> 00:14:55,520
sliding can be harder than token jumping. But there's still a lot of questions to be answered.

135
00:14:58,640 --> 00:15:04,000
All right, so some of you might be asking why do we care about studying such problems?

136
00:15:04,800 --> 00:15:13,280
There's a lot of motivations out there. I mean, as sometimes I would say you don't need motivation,

137
00:15:13,280 --> 00:15:18,480
they're interesting. There's a lot of open questions that we need to answer. But you can also think

138
00:15:18,480 --> 00:15:24,480
about reconfiguration problems as another way of modeling real world algorithmic problems.

139
00:15:24,480 --> 00:15:29,840
Because you usually never start from scratch. When you're trying to solve real world problems,

140
00:15:29,840 --> 00:15:34,720
you usually start from something and you're trying to prove it or make it better or change it

141
00:15:34,720 --> 00:15:42,320
to something more appropriate. Another very good application of studying these problems

142
00:15:42,320 --> 00:15:47,280
is that they give you a better understanding of solution spaces, which can be very important for

143
00:15:47,360 --> 00:15:52,560
other areas as well. And they have been used in statistical physics, quantum computing,

144
00:15:52,560 --> 00:15:58,960
and in complexity theory, combinatorics, and robotics, and hopefully many more applications to come.

145
00:15:58,960 --> 00:16:03,760
But what I would tell you is that there are so many very interesting problems that are so

146
00:16:03,760 --> 00:16:09,120
easy to start thinking about without having too much background, which is why I think this is

147
00:16:09,120 --> 00:16:15,120
a very nice area to start working on at any level in your research career.

148
00:16:18,160 --> 00:16:24,800
All right, so I'll take a break here and take questions if there are any. And then we will dive

149
00:16:24,800 --> 00:16:31,760
into the token jumping and token sliding problems, what we know about them in terms of classical

150
00:16:31,760 --> 00:16:37,280
complexity, and what was basically the starting point for the project that led us to this paper.

151
00:16:37,760 --> 00:16:41,920
Any questions at this point?

152
00:16:45,200 --> 00:16:52,000
I apologize for the small context which I am interrupting here. So this is just to announce

153
00:16:52,000 --> 00:16:58,000
for the PC301 workshop that will be happening in December end. And this will be slightly different

154
00:16:58,000 --> 00:17:03,040
from the previous two workshops. First major difference, this will be online. Second is

155
00:17:03,760 --> 00:17:11,840
some advanced topics what we discuss. So anyone who intends to explore somewhat more complex

156
00:17:11,840 --> 00:17:18,480
topics in parametrize algorithms is invited to have a check. They can look at the website that

157
00:17:18,480 --> 00:17:23,200
has been shared on the chat. And if you wish, you can register simply by filling a form that is

158
00:17:24,400 --> 00:17:30,480
linked at the bottom of the webpage. So just to inform you all about it. And sorry for the

159
00:17:30,480 --> 00:17:42,000
introduction for this now. All right. All right, so let's start talking about token jumping,

160
00:17:42,000 --> 00:17:48,080
token sliding, and a little bit about classical complexity. I know everybody here knows about

161
00:17:48,080 --> 00:17:53,040
P and NP, so I'm not going to talk about this. Some of you might not be familiar with the

162
00:17:53,040 --> 00:17:59,200
PSPACE class. So just a quick note, that's as much as you will need to know for this talk,

163
00:17:59,200 --> 00:18:05,120
is that PSPACE is the set of all decision problems that can be solved using a polynomial

164
00:18:05,120 --> 00:18:11,920
amount of space. And the reason why I mentioned this class is because many, many, many, many

165
00:18:11,920 --> 00:18:19,040
reconfiguration problem actually are PSPACE complete. Okay. And so, so what we know the standard

166
00:18:19,040 --> 00:18:25,120
inclusion is we know that P is contained in NP, which is contained in PSPACE. But a very useful

167
00:18:25,120 --> 00:18:32,560
thing about PSPACE is that Savage proved that it's equal to NP space. So polynomial space and

168
00:18:32,560 --> 00:18:38,560
non-deterministic polynomial space are the same class. Basically, and that's extremely useful

169
00:18:39,280 --> 00:18:43,920
when you start to think about reconfiguration problems because if you think of a reconfiguration

170
00:18:43,920 --> 00:18:50,640
problem where you're given some state and you want to reach the other one. So basically,

171
00:18:50,640 --> 00:18:57,680
you can solve that easily in non-deterministic polynomial space, which basically implies that

172
00:18:57,680 --> 00:19:04,800
they are NP space. But actually, you can show a lot more than that. You can show that many,

173
00:19:04,800 --> 00:19:09,840
really, many reconfiguration problems are actually PSPACE complete, which is not surprising.

174
00:19:10,640 --> 00:19:16,960
Right. The fact that many of these reconfiguration problems are PSPACE complete is not very surprising.

175
00:19:17,520 --> 00:19:24,640
Right. And then, then not being in NP is because they don't always have polynomial size certificates,

176
00:19:24,640 --> 00:19:30,000
which also makes sense because sometimes the number of steps that you need to take to go from

177
00:19:30,000 --> 00:19:36,640
one configuration to the other might very well be exponential in the graph. But there are also

178
00:19:36,640 --> 00:19:42,320
some extremely surprising results. And these are some of the results, some of my favorite results in

179
00:19:42,400 --> 00:19:49,520
the area. So for example, you all know that coloring is NP complete even for K equals three.

180
00:19:50,320 --> 00:19:56,640
However, it turns out that if you try to solve the recoloring problem for K equals three,

181
00:19:57,280 --> 00:20:02,880
it's actually polynomial time-solvable. So if I give you two, three colorings of a graph and I

182
00:20:02,880 --> 00:20:10,720
ask you, is there a path between them that recolors one vertex at a time and is always a valid

183
00:20:10,720 --> 00:20:16,640
three coloring, then this problem can be solved in polynomial time. And the recoloring problem only

184
00:20:16,640 --> 00:20:25,440
becomes PSPACE complete for K equals four and more. Right. So that's the first surprising result.

185
00:20:25,440 --> 00:20:32,640
Another very surprising result is that as your all FBT experts here, I know that you're

186
00:20:32,640 --> 00:20:37,840
all familiar with the fact that usually when we study problems on graphs of bounded bucket width,

187
00:20:37,840 --> 00:20:46,080
path width, tree width, they tend to become easier. It turns out that that's not really the case

188
00:20:46,800 --> 00:20:51,360
for reconfiguration problems, at least for token sliding and jumping, which is the two problems

189
00:20:51,360 --> 00:20:57,280
that are related to independent set. It turns out that those two problems remain PSPACE complete

190
00:20:57,280 --> 00:21:01,760
even if you have a graph of constant tree width or path width or even bucket width.

191
00:21:02,720 --> 00:21:08,640
So a very, very, very simple graph structure still the problem remains hard.

192
00:21:11,120 --> 00:21:18,560
All right. And finally, the last theorem that I also like a lot shows you basically that

193
00:21:18,560 --> 00:21:26,240
sliding and jumping behave differently. And it was shown that if you restrict yourself to

194
00:21:26,240 --> 00:21:31,440
bipartite graphs where we know that max and independent set can be solved in polynomial time,

195
00:21:32,320 --> 00:21:38,560
if you restrict yourself to those graphs, it turns out that token jumping is NP complete,

196
00:21:39,760 --> 00:21:49,920
whereas token sliding is PSPACE complete, which is a strange difference between the behavior

197
00:21:50,000 --> 00:22:02,240
of those two problems. All right. So in fact, we know a lot more about token sliding and token jumping.

198
00:22:02,240 --> 00:22:07,840
These problems have been at the heart of the area of combinatorial reconfiguration. They have

199
00:22:07,840 --> 00:22:14,480
been studied so much. And we know so much about them at least in terms of standard or classical

200
00:22:14,480 --> 00:22:22,160
complexity. So some of the important results for our paper that we're going to focus on

201
00:22:23,840 --> 00:22:30,080
is this result. So that's going to be the starting point of the results that we will discuss

202
00:22:30,080 --> 00:22:35,040
next when we move to parametrize complexity. So the fact that token sliding and token jumping

203
00:22:36,640 --> 00:22:41,840
are PSPACE complete and then NP complete respectively on bipartite graphs was the starting point

204
00:22:41,840 --> 00:22:46,880
of our next paper. But there are some very interesting results here that are also worth mentioning.

205
00:22:46,880 --> 00:22:52,640
So for example, for even whole figure halves, we know how to solve token jumping in polynomial time,

206
00:22:54,000 --> 00:22:58,240
but the complexity of independent set even remains open on this class of graphs.

207
00:22:59,600 --> 00:23:05,360
And the complexity of token sliding also remains open. So we don't know how to check if given

208
00:23:05,360 --> 00:23:11,680
two independent sets, I can slide one to the other. Can you answer that question in polynomial time

209
00:23:11,680 --> 00:23:19,360
for even whole three graphs? For split graphs and chordal graphs, they also behave extremely

210
00:23:19,360 --> 00:23:25,680
differently token sliding and token jumping. So they are token sliding is PSPACE complete on

211
00:23:25,680 --> 00:23:32,240
split graphs and chordal graphs while token jumping is polynomial time. And that is some of the

212
00:23:32,240 --> 00:23:39,200
reasons why we feel that token sliding is harder usually than token jumping, but it's not always the

213
00:23:39,200 --> 00:23:53,680
case. All right, so that's it for classical complexity. So now let's move on to parametrize complexity.

214
00:23:53,680 --> 00:23:59,200
And let's basically think about how you can parametrize those two problems, token jumping and

215
00:23:59,200 --> 00:24:06,960
token sliding. So the obvious parameter would be the number of tokens, right? So one of the obvious

216
00:24:06,960 --> 00:24:13,440
parameters would be the number of tokens. And we're going to denote that by K. Another parameter

217
00:24:13,440 --> 00:24:18,800
would be the length of the sequence, like how many steps does it take to go from one independent set

218
00:24:19,440 --> 00:24:25,120
to the other? You can also obviously parametrize by tree width or path width or any combination of

219
00:24:25,120 --> 00:24:34,080
the above. When we started working on this problem, our initial aim was to basically study the

220
00:24:34,080 --> 00:24:40,800
parametrize complexity of token sliding and token jumping on bipartite graphs using the parameter K

221
00:24:40,800 --> 00:24:46,880
number of tokens, right? Because remember, we saw that token sliding is PSPACE complete on

222
00:24:46,880 --> 00:24:53,600
bipartite graphs and token jumping is NP. So you were interested to see if basically this is going

223
00:24:53,600 --> 00:24:59,120
to give us w1 hardness for token sliding and fptness for token jumping.

224
00:24:59,120 --> 00:25:05,360
All right, at least that was the initial hope. That's why we started working on this project.

225
00:25:06,160 --> 00:25:12,000
We weren't able to answer the two questions. So we were able to answer one side of the question,

226
00:25:12,720 --> 00:25:20,720
which is we were able to show that on bipartite graphs, token sliding is in fact w1 hard.

227
00:25:22,320 --> 00:25:28,160
So token sliding parametrize by the number of tokens on bipartite graphs is w1 hard.

228
00:25:28,720 --> 00:25:35,120
We were not able to answer the question for token jumping. So that is still an open question.

229
00:25:37,040 --> 00:25:42,800
So having answered that question and failed on the next question, we started thinking about ways

230
00:25:42,800 --> 00:25:49,760
to basically simplify a little bit some of these questions. So the next thing we asked ourselves,

231
00:25:49,760 --> 00:25:56,320
so there are two directions where you can try and simplify. So the next thing we asked

232
00:25:56,320 --> 00:26:02,480
ourselves was, okay, so from bipartite graphs, how can I go to other classes of graphs

233
00:26:04,240 --> 00:26:11,200
and see where token jumping becomes hard or easy. And it turned out that if you basically exclude

234
00:26:11,200 --> 00:26:20,480
only c4 from your graph, right? And so we, because in bipartite graphs, you're excluding all

235
00:26:20,640 --> 00:26:28,160
cycles, right? So we started thinking about what kinds of cycles affect the behavior of those

236
00:26:28,160 --> 00:26:34,000
problems. So the first question was, what about c4 free graphs? And it turned out that both problems

237
00:26:34,000 --> 00:26:43,520
remained w1 hard on c4 free graphs. Now, if you exclude c3 and c4, it turns out that token jumping

238
00:26:43,520 --> 00:26:51,200
becomes fpt has an order k squared kernel, but for token sliding, we were not able to determine

239
00:26:51,200 --> 00:27:00,480
the complexity. Now, if you go to the other side of that, so what if we enforce both bipartite

240
00:27:00,560 --> 00:27:09,120
tightness as well as c4 freeness. So in that case, we were able to show that both problems became

241
00:27:09,120 --> 00:27:19,120
fpt. Okay, and basically the bipartite bounded degree graphs was just a stepping stone to get to

242
00:27:19,120 --> 00:27:26,800
the bipartite c4 free graph result. So let me let me repeat that maybe slightly more clearly.

243
00:27:26,800 --> 00:27:32,240
So after basically answering the first question, which was bipartite graphs, we were able to show

244
00:27:32,240 --> 00:27:37,760
that token sliding was w1 hard, but we were not able to determine the complexity of token jumping.

245
00:27:38,560 --> 00:27:44,800
So then we went to c4 free graphs, and we were able to show that both problems are actually w1

246
00:27:44,800 --> 00:27:51,760
hard. Then if we added one more constraint, which was c3 c4 free graphs, we got fpt

247
00:27:52,240 --> 00:27:59,520
token jumping, but it remained open for token sliding. And on the other side of the spectrum, so

248
00:27:59,520 --> 00:28:05,200
if we keep bipartite and enforce the c4 freeness, we get fpt for both problems.

249
00:28:08,240 --> 00:28:15,120
And as a side note, this blue result is not part of our paper. This was known prior to our

250
00:28:15,840 --> 00:28:31,040
paper. So any questions about the results?

251
00:28:31,200 --> 00:28:50,400
No questions. All right, cool. So lots of open problems. The first and obvious one is what is the

252
00:28:50,400 --> 00:28:56,880
pattern is a token jumping fpt parameterized by k on bipartite graphs. And that's really,

253
00:28:56,880 --> 00:29:03,280
I mean, that was the initial question that we set out to answer. And couldn't. So that remains open.

254
00:29:04,880 --> 00:29:13,440
And so I will not be going over the hardness reduction for token sliding on bipartite graphs,

255
00:29:13,440 --> 00:29:19,760
because it's quite technical. I don't feel a talk is the right place to go over it. But

256
00:29:20,640 --> 00:29:27,760
if you go over the reduction, you will see that it's the two problems really behave differently,

257
00:29:27,760 --> 00:29:33,280
and there's that doesn't seem to be a chance to basically make the same type of reduction work for

258
00:29:33,280 --> 00:29:40,960
token jumping. So the second interesting open question is how about token jumping parameterized

259
00:29:40,960 --> 00:29:45,920
by k on triangle free graphs? That's basically even more general than question one.

260
00:29:46,880 --> 00:29:53,360
Right. So, and the reason why I mentioned this question separately is because almost every reduction

261
00:29:53,360 --> 00:30:01,200
that I know of includes large clicks. So you need to use large clicks in your reductions. So how about

262
00:30:01,200 --> 00:30:08,080
if we don't allow triangle and large clicks? So can we can we can we then say something about the problem?

263
00:30:08,960 --> 00:30:16,320
So that's for token jumping. Now, when when you go to token sliding. So so the open problem is

264
00:30:17,280 --> 00:30:23,520
what happens for token sliding on graphs of girth at least five. So if they are c3 c4 free.

265
00:30:24,240 --> 00:30:31,440
Or you can even make that a bit weaker and ask for any girth of at least p for some constant p.

266
00:30:33,840 --> 00:30:37,200
And for all of these questions, of course, polynomial kernels.

267
00:30:38,560 --> 00:30:45,040
would be interesting as well. Because in our case, we do get polynomial kernels for the FPD.

268
00:30:47,600 --> 00:30:53,280
And the polynomials are not great, but polynomial regardless.

269
00:30:56,640 --> 00:31:03,680
All right. So in the rest of the talk, I will try to cover some of the technical stuff.

270
00:31:03,680 --> 00:31:09,360
And as promised, I will try to keep it as light as possible so that I can give you some of a lot

271
00:31:09,360 --> 00:31:15,920
of the intuition and techniques that are used in this paper and that are generally used when

272
00:31:15,920 --> 00:31:21,600
dealing with reconfiguration problems. So the first result that we will go over is this W

273
00:31:21,600 --> 00:31:27,360
hardness on c4 free graphs. Right. For both token sliding and token jumping. It's the same

274
00:31:27,360 --> 00:31:35,600
reduction and you will get both results because we will be using maximum independent sets.

275
00:31:36,480 --> 00:31:43,120
So if you're trying to basically do token sliding from one maximum independent set to the other

276
00:31:43,840 --> 00:31:48,880
or token jumping, these two rules become equivalent. Jumping becomes equivalent to sliding.

277
00:31:49,520 --> 00:31:54,400
So when you're dealing with maximum independent sets, these two basically rules are the same.

278
00:31:55,360 --> 00:31:59,440
And that's what we're going to do. But what we're going to prove actually is a stronger

279
00:31:59,440 --> 00:32:05,440
theorem. What we're going to prove is the following theorem. If you take any p greater than or equal

280
00:32:05,440 --> 00:32:15,200
to four, then both problems are W hard on c4 c5 dot dot dot up to cp free graphs,

281
00:32:15,920 --> 00:32:26,400
which implies, of course, c4 free graphs. But you can basically exclude any cycles from c4 up

282
00:32:26,400 --> 00:32:30,640
to cp for constant p and the problems will remain W1 hard.

283
00:32:36,960 --> 00:32:43,040
So how do we prove this result? In fact, we use a known reduction from a problem known

284
00:32:43,040 --> 00:32:51,440
as grid tiling, which is a W1 hard problem. And grid tiling is reduced to the independent set problem

285
00:32:51,440 --> 00:33:00,320
on c4 up to cp free graphs. And that reduction was used to show that independent set remains

286
00:33:00,320 --> 00:33:09,360
W1 hard if you exclude c4 up to cp for any constant p. But what is interesting and useful in that

287
00:33:09,360 --> 00:33:16,080
reduction is the graph that is obtained from the reduction. So the graph that is obtained from

288
00:33:16,080 --> 00:33:22,800
the reduction has three properties that are going to be useful to us. The first property is that you

289
00:33:22,800 --> 00:33:31,680
can partition the graph into basically 8k squared into p plus 1 clicks. So you have a bunch of

290
00:33:31,680 --> 00:33:36,880
clicks, each of size n, and all of the edges basically are between the clicks.

291
00:33:38,960 --> 00:33:44,560
But that's it, that's it, that's the whole of the graph. It's a bunch of clicks and edges between them.

292
00:33:45,680 --> 00:33:52,480
Of course, the more important property as well here is that this graph is going to be c4 up to cp free.

293
00:33:52,880 --> 00:34:03,040
It will not have any of those cycles as an induced sub graph. And it's an equivalent instance to

294
00:34:03,040 --> 00:34:11,200
the grid tiling. And that basically gives you a W1 hardness of independent set on this class of graphs.

295
00:34:13,360 --> 00:34:19,760
So notice in this case that an independent set of size 8k squared into p plus 1 will have to be

296
00:34:19,760 --> 00:34:23,760
a maximum independent set because that's how many clicks we get in the resulting graph.

297
00:34:24,480 --> 00:34:29,840
And that's basically the sizes that we will be working with, more or less up to some modifications.

298
00:34:30,400 --> 00:34:38,400
But this will allow us to basically conclude that both sliding and jumping are hard on this class of graphs.

299
00:34:41,360 --> 00:34:48,960
So how do we use this for showing hardness of token sliding and token jumping? And let's focus on

300
00:34:48,960 --> 00:34:56,000
token sliding for now because it's going to be the same anyway. So we have those clicks and some edges

301
00:34:56,000 --> 00:35:04,080
that go between the clicks. So the first attempt would be as follows. We will add a universal vertex

302
00:35:04,080 --> 00:35:09,360
to each one of the clicks. And we will call this the starting set or the starting independent set.

303
00:35:10,400 --> 00:35:15,200
And then we add another universal vertex to each one of the clicks and call this the target

304
00:35:15,200 --> 00:35:21,360
independent set. And now basically we have our instance of token sliding. We want to slide everybody

305
00:35:21,360 --> 00:35:31,040
in S down to T. So notice that this is useful because we don't introduce any of the forbidden cycles.

306
00:35:31,680 --> 00:35:40,160
So we are still fine. And if we could guarantee that all of the tokens will be on the on the clicks

307
00:35:40,240 --> 00:35:47,360
simultaneously then this will imply an independent set in the original graph which concludes our proof.

308
00:35:48,080 --> 00:35:56,320
But unfortunately in this case we definitely cannot conclude that because each red token can slide

309
00:35:56,320 --> 00:36:03,440
independently here and then here and then the next one can follow etc etc etc. So you need some way

310
00:36:03,440 --> 00:36:11,200
of forbidding these tokens to behave freely. We want to make sure that they will all be

311
00:36:12,240 --> 00:36:18,000
inside the clicks simultaneously and we will be done. And notice that we're going to have 8K

312
00:36:18,000 --> 00:36:24,000
squared and 2p plus 1 tokens right, 1 for each click and 2 universal vertices for each click.

313
00:36:24,880 --> 00:36:34,560
So how do we fix this simultaneously issue? Well here's how we can do it. So instead of simply adding

314
00:36:34,560 --> 00:36:40,960
universal vertices we're also going to add an edge between every two universal vertices of a click

315
00:36:41,680 --> 00:36:47,200
and then we're going to add something that we call a switch. And in this case it's a simple edge

316
00:36:48,160 --> 00:36:56,400
and the red token here needs to go to the blue position. Right so now we have one extra token

317
00:36:56,400 --> 00:37:05,120
inside our graph. But now notice what happens. If any red token wants to come to the blue

318
00:37:06,000 --> 00:37:13,520
position then this red token needs to be moved to this position before. And if you move that token

319
00:37:13,520 --> 00:37:19,440
up to the blue position then you can no longer have any of the red tokens on the universal vertices

320
00:37:19,440 --> 00:37:26,160
which means that they will all have to be simultaneously inside the clicks. And now we get the

321
00:37:26,160 --> 00:37:33,520
behavior that we want. So now we can guarantee that if there is a sequence that takes the red tokens

322
00:37:33,520 --> 00:37:41,280
to the blue position then somewhere along that sequence the tokens are all going to be within the

323
00:37:41,280 --> 00:37:46,960
clicks. Unfortunately what happened here is we might have introduced some of the forbidden cycles.

324
00:37:47,760 --> 00:37:56,320
We can no longer guarantee that this is c4 up to cp3. So what you can do in this case to solve

325
00:37:56,320 --> 00:38:01,920
this problem and I'm not going to go into the details but the intuition should be pretty clear

326
00:38:01,920 --> 00:38:08,320
is that you can subdivide those edges make them long enough so that you don't introduce any

327
00:38:08,320 --> 00:38:13,040
forbidden cycles and add appropriate tokens inside of them to get the same behavior.

328
00:38:15,200 --> 00:38:19,760
Because notice that the number of such edges is bounded by a function of k,

329
00:38:20,560 --> 00:38:31,280
by a function of yes k and p. So you can make these edges subdivide them as many times as needed,

330
00:38:31,280 --> 00:38:37,040
add as many tokens as needed to maintain all the properties that we need and to maintain that

331
00:38:37,040 --> 00:38:42,800
we're going from one maximum independent set to the other. Which will give you W1 hardness

332
00:38:42,800 --> 00:38:55,200
for both token sliding as well as token jumping. All right. Questions?

333
00:39:07,680 --> 00:39:10,720
No questions. All right. So let's keep going.

334
00:39:13,680 --> 00:39:21,360
So now I'm going to talk about some positive result. So the result that I'm going to talk about

335
00:39:21,360 --> 00:39:31,200
is this one here. All right. So I'm going to show you that on c3 c4 free rafts token jumping is

336
00:39:31,200 --> 00:39:38,480
actually fpt and has a quadratic kernel. But again, what we will show is a stronger result.

337
00:39:39,520 --> 00:39:43,600
So what we will show is the following theorem. What we will show

338
00:39:46,720 --> 00:39:50,720
is can be summarized as follows. So if you look at any graph

339
00:39:52,880 --> 00:39:57,680
or at any instance of the token jumping problem. So remember, an instance of token jumping has

340
00:39:57,920 --> 00:40:02,800
an input graph, the starting set, the target set, and k as the number of tokens.

341
00:40:04,480 --> 00:40:13,680
So let me try and draw something here. So if you look at your graph, you can kind of decompose it

342
00:40:13,680 --> 00:40:20,880
into something which is more or less as follows. So you have s, you have t, their intersection

343
00:40:20,880 --> 00:40:30,480
need not be empty. And then you have the neighborhood of s union t. And then you have the rest of the graph.

344
00:40:33,120 --> 00:40:39,440
So we're going to call the rest of the graph h. And we're going to call the close neighborhood

345
00:40:39,440 --> 00:40:49,200
of s union t. Or if you will this yellow part here, we call that j. So we can think of our problem

346
00:40:49,200 --> 00:40:53,520
of our graph as being decomposed into those two areas, h and j.

347
00:40:55,520 --> 00:41:04,480
Okay, so the theorem states the following. If h is epsilon sparse, where epsilon sparse means

348
00:41:04,480 --> 00:41:11,920
that the number of edges is at most n squared minus epsilon positive epsilon. So if h is epsilon sparse

349
00:41:12,640 --> 00:41:23,200
and j is c3 c4 free, then the problem admits a kernel which is that big, k squared plus k into

350
00:41:23,200 --> 00:41:30,160
one plus one over epsilon. So notice now that we only need that h is epsilon sparse.

351
00:41:31,760 --> 00:41:41,360
And we only require c3 c4 freeness inside j, which is s union t close neighborhood of s union t.

352
00:41:42,160 --> 00:41:53,120
And this idea is actually is not a new idea. So this idea is is, okay, I had the drawing here. I

353
00:41:53,120 --> 00:41:59,680
should have used it. So the idea comes from from has been used before. And it's what we call the

354
00:41:59,680 --> 00:42:04,480
buffer technique for the token jumping problem. And then the solution behind the buffer technique is

355
00:42:04,560 --> 00:42:12,640
very simple. So if I have s union t, but somewhere in the graph, which is not in the close neighborhood

356
00:42:12,640 --> 00:42:19,920
of s union t, I have a k-sized independent set, then you are done, right? If I have a k-sized

357
00:42:19,920 --> 00:42:28,400
independent set in h, then you're done. You can basically take all the tokens on s, jump them into

358
00:42:29,360 --> 00:42:36,480
independent yellow vertices in h, and then jump them back to t. So in some sense, when h has a

359
00:42:36,480 --> 00:42:43,200
large independent set, that's the easy case, right? You're done. If you can find a large enough

360
00:42:43,200 --> 00:42:49,280
independent set in h, you're done. And that's what we call the buffer technique. Because it's been

361
00:42:49,280 --> 00:42:56,720
also used to show that the problem is fpt on planar graphs, for example, or k3 j free graphs. So

362
00:42:56,720 --> 00:43:11,440
graphs without large bytes. So it's a well known technique. All right. So what do we show? So we're

363
00:43:11,440 --> 00:43:14,560
going to use the buffer technique and we're going to combine it with something else.

364
00:43:17,200 --> 00:43:23,760
So we show that you have a yes instance, whenever one of those two conditions is true.

365
00:43:23,920 --> 00:43:32,960
The first condition is that h is epsilon sparse and contains more than this many vertices.

366
00:43:34,480 --> 00:43:40,960
And this is relatively easy. When you contain this many vertices and you add epsilon sparse,

367
00:43:40,960 --> 00:43:45,520
then you will have a k-sized independent set. And that's basically the buffer technique.

368
00:43:46,400 --> 00:43:51,920
When h is epsilon sparse and has that many vertices or more, then h is guaranteed to have an

369
00:43:51,920 --> 00:43:58,640
independent set of sts k and you're done. So now you are stuck with what happens inside j

370
00:43:59,520 --> 00:44:05,600
or the closed neighborhood of s union t. And it turns out there, if you have c3c for

371
00:44:05,600 --> 00:44:12,720
freeness, the only thing you need on top of that to guarantee a yes instance is a vertex of

372
00:44:12,720 --> 00:44:23,760
degree at least 3k. So if you have c3c for freeness inside j and the vertex of degree 3k, then again,

373
00:44:23,760 --> 00:44:32,160
you get a yes instance. So let me prove those two statements separately, because they will be

374
00:44:32,160 --> 00:44:41,360
basically what we need for the final theorem, for the final theorem. So the first lemma, as I told

375
00:44:41,920 --> 00:44:48,400
you, if h is epsilon sparse and has more than this many vertices, then it's a yes instance,

376
00:44:48,400 --> 00:44:55,040
because you have a k-sized independent set in h. The idea of this proof is simple. It's a counting

377
00:44:55,040 --> 00:45:01,360
argument. And what you need to do basically first is to show that h must contain a vertex of degree

378
00:45:01,360 --> 00:45:07,920
less than an over k. And then basically you apply the standard greedy packing algorithm for

379
00:45:07,920 --> 00:45:13,600
constructing an independent set of size k. And the reason you show that the way you show that h

380
00:45:13,600 --> 00:45:19,920
has a vertex of degree less than an over k is, again, standard counting argument and the

381
00:45:19,920 --> 00:45:25,840
hand shaking lemma, right? So if the minimum degree in h was at least n over k, then the number

382
00:45:25,840 --> 00:45:33,760
of edges would be at least n squared over 2k, which will only happen in an epsilon sparse graph

383
00:45:33,840 --> 00:45:42,400
when n is less than or equal 2k to the power 1 over f. And the rest of the proof is basically an

384
00:45:42,400 --> 00:45:49,520
induction on k. Okay, and so that shows you that when you do have an epsilon sparse graph with

385
00:45:49,520 --> 00:45:58,400
more than this many vertices, then we have a yes instance. All right, so how about the second part

386
00:45:59,200 --> 00:46:06,080
of the claim? So now what happens if we have a c3 c4 free j that has a vertex of degree 3k?

387
00:46:06,960 --> 00:46:12,480
Well, let's see what happens. So if we have a vertex of degree 3k, and I'm going to

388
00:46:13,680 --> 00:46:19,840
circle it here in yellow. So how can the neighborhood of that vertex look? Well, we know that j

389
00:46:19,840 --> 00:46:26,560
is c3 free. So the blue edges cannot exist, which means that the neighborhood of the yellow vertex

390
00:46:26,640 --> 00:46:34,960
is an independent set inside j, not in the whole graph. Well, in fact, in the whole, well, no,

391
00:46:34,960 --> 00:46:42,560
because we're only talking about j as a sub graph. Right? So the blue edges cannot exist,

392
00:46:42,560 --> 00:46:45,040
because otherwise we will get a c3 inside j.

393
00:46:46,000 --> 00:46:54,560
All right, so now let's look at the other vertices in s union t.

394
00:46:55,920 --> 00:47:02,400
The other, the second observation that you need is that any vertex other than the yellow vertex

395
00:47:02,400 --> 00:47:08,880
can have at most one neighbor in common with the yellow vertex. Because if you do have two

396
00:47:08,880 --> 00:47:18,320
neighbors in common, then you will get a c4. So now what happens if we have three

397
00:47:18,320 --> 00:47:25,520
k vertices in the neighborhood of the yellow vertex? Well, at most two k of them can be connected

398
00:47:26,640 --> 00:47:32,400
to some vertex in s union t, and you will get at least k of them, some k of them here

399
00:47:32,720 --> 00:47:42,160
that are only connected to the yellow vertex. And so now basically instead of using a buffer inside

400
00:47:42,160 --> 00:47:49,920
h, we have just found a buffer inside j, and we can use the same strategy. We can jump all the

401
00:47:49,920 --> 00:47:56,080
tokens here, starting of course by the yellow token, and then jump them to where they need to go.

402
00:48:03,200 --> 00:48:13,360
So now combining those two observations together, if you will, we get the following theorem.

403
00:48:13,360 --> 00:48:20,320
So if h is alpha sparse, and j is c3c for free, then the problem admits a kernel on this

404
00:48:20,320 --> 00:48:26,400
maneuver to c's, and it's basically a simple application of the previous two lemmas. If we have

405
00:48:26,400 --> 00:48:32,400
more than this maneuver to c's in h, it's a trivial yes instance. If j has a vertex of

406
00:48:32,400 --> 00:48:38,480
degree 3k or more it's trivial yes instance, and now you combine all of this together, we know

407
00:48:38,480 --> 00:48:44,960
that s union t is of size at most 2k. We know that the neighborhood of s union t is of size at

408
00:48:44,960 --> 00:48:51,680
most 2k times 3k, which is roughly 6k squared. And now we know that the rest of the graph has

409
00:48:51,680 --> 00:48:58,160
at most that maneuver to c's. So basically use some of those numbers, and you get this bound.

410
00:49:06,400 --> 00:49:12,240
All right, so how does this theorem imply the result that I promised you to start with?

411
00:49:12,720 --> 00:49:22,000
So that token jumping and token sliding admit kernel with order k squared to c's,

412
00:49:23,360 --> 00:49:28,960
I mean, I mean, it also holds for bipartite c for free graphs, right? Obviously because they are c3c

413
00:49:28,960 --> 00:49:37,360
for free. So how do you get the kernel? Well, we know that j cannot contain more than 6k squared

414
00:49:37,360 --> 00:49:46,720
minus 2k vertices, and we know from another theorem from another paper that c3 free graphs

415
00:49:47,760 --> 00:49:52,240
with k squared over logk vertices must have an independent set of size at least k.

416
00:49:53,600 --> 00:49:58,320
And now we know that if h contains more than this maneuver to c's that we will get the yes instance

417
00:49:58,320 --> 00:50:06,320
as well, right? So it becomes an immediate consequence of the previous theorem, but the previous

418
00:50:06,320 --> 00:50:11,920
theorem is even more general than this corollary. So this corollary does not really use the full power

419
00:50:11,920 --> 00:50:23,200
of this theorem. All right, that's it. I think I'm fine. If you have questions, I will take them now.

420
00:50:23,200 --> 00:50:34,880
So it was 55 minutes, right? For the talk, I did not go under the talk.

421
00:50:34,880 --> 00:50:39,120
Yeah, it's fine. We usually allow plus minus 10 minutes. That's all right.

422
00:50:42,400 --> 00:50:45,920
So I have a question about token sliding. Yes.

423
00:50:46,800 --> 00:50:54,320
So how crucial, what happens if one does not restrict the independent sets during the configuration

424
00:50:55,440 --> 00:51:02,560
to be not of the same size? Is that very critical for the difficulty or the easiness of the problem?

425
00:51:03,680 --> 00:51:08,560
Well, you have to be careful how you define that because in token sliding,

426
00:51:09,520 --> 00:51:15,680
tokens cannot leave the graph. That's correct, but the independent set sequence

427
00:51:15,680 --> 00:51:18,320
all the independence sets have to be the same size, right?

428
00:51:18,320 --> 00:51:24,080
Well, if not some token disappeared at some point and I'm not sure how it disappeared,

429
00:51:26,400 --> 00:51:31,680
right? Because you start with something of size K and you're going to something of size K,

430
00:51:31,680 --> 00:51:40,080
you cannot leave the graph unless you define it in some way. So you will remain of size K throughout.

431
00:51:41,040 --> 00:51:46,080
But you can become slightly larger in K. But where does the new token come from?

432
00:51:49,040 --> 00:51:55,120
So there is a third rule that I did not tell you about which is called token addition and removal.

433
00:51:56,960 --> 00:52:03,520
Under that rule, we actually allow you to remove vertices and adversities as long as you remain

434
00:52:03,520 --> 00:52:12,240
an independent set of size at least K. Does that answer your question?

435
00:52:12,240 --> 00:52:19,200
Yeah, yeah, yeah, yeah, yeah. But in fact, it was shown that it was shown that

436
00:52:20,720 --> 00:52:23,680
so addition and removal is equivalent to token jumping.

437
00:52:25,920 --> 00:52:30,560
But it doesn't, it never makes sense to add more tokens to your graph if you don't need them.

438
00:52:34,400 --> 00:52:37,360
You're only making your life harder into it and be speaking.

439
00:52:41,120 --> 00:52:49,840
So the other question that I had is, I mean, I heard, so is it possible to view this whole problem

440
00:52:50,880 --> 00:52:56,400
on an exponential size graph where every vertex corresponds to a

441
00:52:57,280 --> 00:53:04,000
independent set in the original graph. And then you have edges between two vertices.

442
00:53:04,880 --> 00:53:09,520
If there is an edge between two vertices of the independent set, and now you are doing a reachability

443
00:53:09,520 --> 00:53:15,520
question, is that a meaningful way to think about this? But that's exactly what we're doing.

444
00:53:16,400 --> 00:53:22,240
But so the way you define your adjacency, I think, so you mean you define, you make two

445
00:53:22,240 --> 00:53:27,360
independent sets adjacent if one can be reached from the other via a single slide or a single joint.

446
00:53:27,360 --> 00:53:31,360
Exactly. Yeah, one edge here. There is one pair, you would be which is adjacent.

447
00:53:32,080 --> 00:53:34,400
But that's, but that's exactly what we're doing.

448
00:53:34,400 --> 00:53:41,120
Okay, okay. Yeah, right? I mean, if you, because we're looking at algorithms here, we kind

449
00:53:41,120 --> 00:53:46,720
of forget the structural picture behind it. But this algorithm is finding a path in this graph

450
00:53:46,720 --> 00:53:52,640
that you're describing. Yeah, yeah, that's it. And what we're saying is you can do it in FBT time

451
00:53:53,440 --> 00:53:55,680
or not, depending on the problem we're talking about.

452
00:54:05,360 --> 00:54:09,280
Hi Amir. Hi. How are you?

453
00:54:09,280 --> 00:54:18,400
Hi. Yeah, I'm good. So I had a question. So, do problems remain equally hard if we bound the,

454
00:54:18,400 --> 00:54:24,720
if we have a restriction on the number of times, we can move the token to a particular vertex.

455
00:54:28,160 --> 00:54:31,920
The number of times you can move a token to a particular vertex.

456
00:54:33,200 --> 00:54:36,400
Like, the number of times the tokens can be moved to a vertex.

457
00:54:37,360 --> 00:54:44,640
Well, that's definitely going to change the complexity in, at least intuitively speaking, right?

458
00:54:44,640 --> 00:54:50,240
Because now you're saying maybe it will, if you're bounding that by a constant, then you might

459
00:54:50,240 --> 00:54:57,680
be saying that I'm not allowing exponentially large sequences anymore. But in terms of exactly how

460
00:54:57,680 --> 00:55:03,280
the complexity changes, I don't have answers. I think it's a very nice question to pose.

461
00:55:03,520 --> 00:55:10,480
Even in terms of a non-parameterized complexity, standard complexity, I think that that would be

462
00:55:10,480 --> 00:55:17,360
a very interesting question because it will definitely affect the behavior. I'm not sure exactly how yet.

463
00:55:17,360 --> 00:55:22,720
I don't know of any results that ask this particular question.

464
00:55:22,720 --> 00:55:28,560
Okay, so I have one more question in the double columnist result that you presented.

465
00:55:29,040 --> 00:55:36,560
So, do you know what is the length of the, the length of the changes?

466
00:55:36,560 --> 00:55:39,920
Actually, the number of changes or flips that you make in your independent set?

467
00:55:41,280 --> 00:55:48,880
This is just, yes, yes, yes, we do. So, here the number of changes is going to be where it's

468
00:55:48,880 --> 00:55:56,240
basically going to be the shortest possible sequence. So, it's basically going to be,

469
00:55:56,800 --> 00:55:59,920
so if you think about the simple construction, this one,

470
00:56:04,000 --> 00:56:09,200
it's basically literally going to be these guys are going to move here. So, H is going to cost

471
00:56:09,200 --> 00:56:14,080
me one slide, and then they're all going to, and now this guy is going to move here,

472
00:56:14,960 --> 00:56:21,280
and now I will pay one slide for each one here. Now, this is the simplified version of it.

473
00:56:21,280 --> 00:56:25,760
Once you go to the complete version of it, you have some extra slides within the path,

474
00:56:26,240 --> 00:56:32,960
but you can also count those. Okay, so, but does this mean that, so,

475
00:56:34,160 --> 00:56:39,200
does this mean that at a particular vertex, we are placing the token at most once?

476
00:56:40,880 --> 00:56:49,440
In this case, yes. Okay. In this case, yes. Okay, so this problem should be hard even if we bound

477
00:56:49,440 --> 00:56:52,640
the number of times tokens can be moved to a vertex, right?

478
00:56:52,640 --> 00:57:02,720
Okay. Yes. Okay. Yes. So, so here in this case, yes. Absolutely. Okay, thanks.

479
00:57:04,400 --> 00:57:12,320
So, Akansha, I have a remark about your question. So, if a vertex, if a vertex cannot get

480
00:57:12,320 --> 00:57:18,080
a token to I's, then it somehow seems to be selecting disjoint independent sets,

481
00:57:18,800 --> 00:57:25,840
it's a sequence of them, and that may have some bearing on coloring, just a top level top.

482
00:57:29,840 --> 00:57:35,920
So, actually for the list, the W hardness case that Amit presented, it is exactly the case,

483
00:57:35,920 --> 00:57:41,280
right? So, we are not allowed to move the token like twice on the same vertex.

484
00:57:42,240 --> 00:57:49,360
Yeah. So, I didn't get your point of meaning, so getting this disjoint independence, it's actually,

485
00:57:50,080 --> 00:57:55,200
because if you say, if you think of it from my, the way I thought about it, right, that you are

486
00:57:55,200 --> 00:58:00,000
actually trying to find a path in a large graph where every vertex corresponds to an independent

487
00:58:00,000 --> 00:58:07,680
set, and you move from one independent set to another. What? So, but we can only move from one

488
00:58:07,680 --> 00:58:16,160
independent set to the other, if the, the changes is like in case of token sliding, it's one

489
00:58:16,160 --> 00:58:28,560
probably. Yeah. So, it looks to be that you are asking for a collection of independence sets,

490
00:58:28,560 --> 00:58:33,920
which are vertex disjoint, if the token sequence of independence sets, which are vertex disjoint.

491
00:58:34,880 --> 00:58:41,520
Yeah. So, if I may, I think, I think a conscious question would be more relevant in a place where

492
00:58:41,520 --> 00:58:47,600
we don't have a monotone sequence, meaning a sequence. So, we need a version of the problem,

493
00:58:47,600 --> 00:58:51,920
or some cases of the problem, where a vertex has to be visited multiple times

494
00:58:53,520 --> 00:58:58,880
to find solutions, and that is known to be the case for some versions or some statements of

495
00:58:58,880 --> 00:59:04,080
the problem. And, and in fact, the conscious also, this is also, this was the crucial difference

496
00:59:04,080 --> 00:59:09,920
between piece-based completeness and NP completeness of sliding versus jumping in bipartite graphs.

497
00:59:11,040 --> 00:59:15,680
So, it was because we were able to show that no vertex will be visited more than once.

498
00:59:17,440 --> 00:59:21,760
Okay. And the other problem. So, so, so that's why it's, it's definitely an interesting question

499
00:59:21,760 --> 00:59:24,960
to pose, but you have to be careful in what context you pose it.

500
00:59:26,160 --> 00:59:33,600
Great. I don't know if that kind of settles, answers your question.

501
00:59:34,480 --> 00:59:39,120
Yes, yes, it does. All right. Thanks. You're welcome.

502
00:59:47,040 --> 00:59:48,080
Any more questions?

503
00:59:51,760 --> 00:59:53,760
Yes.

504
01:00:23,760 --> 01:00:27,720
I'll just once again announce the parametrials to go

505
01:00:27,720 --> 01:00:30,720
on the 301 workshop, which is going to happen in December

506
01:00:30,720 --> 01:00:35,280
in the link has been posted once again in the chat.

507
01:00:35,280 --> 01:00:37,280
Some advanced topics in parametrious

508
01:00:37,280 --> 01:00:38,800
complicity will be discussed.

509
01:00:38,800 --> 01:00:43,800
Those interested can have a look and register for it.

510
01:00:43,800 --> 01:00:47,920
And yeah, if there are some more questions, please ask away.

511
01:00:53,760 --> 01:01:19,200
So anyone can register for the school?

512
01:01:19,200 --> 01:01:23,440
Yes, yes, anyone can.

513
01:01:23,440 --> 01:01:28,160
Yeah, it's free and it's online and yeah, it's open to everyone.

514
01:01:28,160 --> 01:01:30,400
Awesome, so I can share it with my students as well.

515
01:01:30,400 --> 01:01:32,480
Of course, of course, please do, yeah, that will be good.

516
01:01:32,480 --> 01:01:36,960
And we assume some basic understanding of parametrious algorithms,

517
01:01:36,960 --> 01:01:40,480
but we have already shared a link on the page

518
01:01:40,480 --> 01:01:44,240
where students can go and go through some

519
01:01:44,240 --> 01:01:46,480
previous lectures in parametrious algorithms

520
01:01:46,480 --> 01:01:50,320
if they wish to just brace up or revise stuff.

521
01:01:57,520 --> 01:02:04,400
All right, so I guess, OK, I don't think there are any more questions.

522
01:02:04,400 --> 01:02:06,800
So I think it's a good time to wrap up.

523
01:02:06,800 --> 01:02:10,880
So thank you once again for the summit or for

524
01:02:10,880 --> 01:02:11,920
agreeing to give the talk.

525
01:02:11,920 --> 01:02:14,960
It was really nice to have you and just really good to have

526
01:02:14,960 --> 01:02:18,160
something different than what we usually hear in every parametrious

527
01:02:18,160 --> 01:02:20,880
context at the top, at least most of them.

528
01:02:20,880 --> 01:02:26,160
So, and yeah, these are really interesting problems, do you think of one?

529
01:02:26,160 --> 01:02:28,560
And thank you to the audience for being with us.

530
01:02:28,560 --> 01:02:30,160
And that's it for today.

531
01:02:30,160 --> 01:02:30,760
We wrap up.

532
01:02:30,760 --> 01:02:32,440
See you all next week.

533
01:02:32,440 --> 01:02:33,160
Thank you.

534
01:02:33,160 --> 01:02:34,160
Bye.

535
01:02:34,160 --> 01:02:35,160
Thank you, bye-bye.

