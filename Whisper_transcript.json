[
  {
    "start": "00:00:00,000",
    "end": "00:00:08,160",
    "text": "So, hello everyone. Welcome to the PC Seminar. Today we have this Professor Amir Mohad from"
  },
  {
    "start": "00:00:08,160",
    "end": "00:00:13,040",
    "text": "American University of Beirut and he'll be talking on the FART and Parametri's complex"
  },
  {
    "start": "00:00:13,040",
    "end": "00:00:18,080",
    "text": "city of token sliding and token jumping. Thank you for joining us, Professor. Over to you now."
  },
  {
    "start": "00:00:19,440",
    "end": "00:00:23,760",
    "text": "Thank you, President. Thank you for having me. It's a real pleasure to be here."
  },
  {
    "start": "00:00:23,760",
    "end": "00:00:32,640",
    "text": "So, all right, let's jump right into it. So, since I did not really know the audience too well,"
  },
  {
    "start": "00:00:32,640",
    "end": "00:00:39,920",
    "text": "I made the assumption that many of you maybe have not seen this area of combinatorial"
  },
  {
    "start": "00:00:39,920",
    "end": "00:00:46,400",
    "text": "reconfiguration problems. So, I decided what I'm going to do is I'm going to give a gentle introduction"
  },
  {
    "start": "00:00:46,400",
    "end": "00:00:51,920",
    "text": "to the area just to show you how many exciting problems and open problems are there."
  },
  {
    "start": "00:00:52,800",
    "end": "00:00:59,520",
    "text": "And then I will talk more about token jumping and neck sliding, specifically what we know about them,"
  },
  {
    "start": "00:00:59,520",
    "end": "00:01:05,840",
    "text": "what we knew about them before we started working on this project, what we managed to discover"
  },
  {
    "start": "00:01:05,840",
    "end": "00:01:11,840",
    "text": "and the tons of questions that remain to be answered. Right, and it's a really,"
  },
  {
    "start": "00:01:13,600",
    "end": "00:01:19,280",
    "text": "I mean, the questions are so nice to state, so easy to state, and they are accessible really to"
  },
  {
    "start": "00:01:19,360",
    "end": "00:01:25,600",
    "text": "researchers at any level, which is one of the reasons why I enjoy working on these problems. So,"
  },
  {
    "start": "00:01:25,600",
    "end": "00:01:32,800",
    "text": "so hopefully you'll get to enjoy them too. So, before I start, I should point out that this is"
  },
  {
    "start": "00:01:32,800",
    "end": "00:01:40,480",
    "text": "joint work that started back in the combinatorial reconfiguration workshop almost two years ago."
  },
  {
    "start": "00:01:42,160",
    "end": "00:01:47,440",
    "text": "And it's joint work with Valentine Bart\u00e9, Nicolabuske, Le Mandalard, and Karl Lomer,"
  },
  {
    "start": "00:01:47,440",
    "end": "00:01:57,680",
    "text": "who is my master's student. All right, so the outline of the talk, it's going to be in four sections."
  },
  {
    "start": "00:01:58,960",
    "end": "00:02:04,640",
    "text": "I will give a gentle introduction to combinatorial reconfiguration, because I know many of you might not"
  },
  {
    "start": "00:02:04,640",
    "end": "00:02:12,960",
    "text": "have seen such problems. Then I will talk about token jumping and token sliding, what we know about"
  },
  {
    "start": "00:02:13,120",
    "end": "00:02:19,360",
    "text": "them in terms of classical complexity or one-dimensional complexity. Then I'll talk about the"
  },
  {
    "start": "00:02:19,360",
    "end": "00:02:24,720",
    "text": "parameter as complexity of these two problems and what we know as of today, as we speak,"
  },
  {
    "start": "00:02:25,520",
    "end": "00:02:31,120",
    "text": "and what are the problems that remain to be solved. And then the last part of the lecture is where"
  },
  {
    "start": "00:02:31,120",
    "end": "00:02:37,200",
    "text": "I will put some of the technical stuff to show you to give you an idea about how we prove things"
  },
  {
    "start": "00:02:37,200",
    "end": "00:02:42,640",
    "text": "when we deal with such problems and where are the difficulties and what kind of techniques"
  },
  {
    "start": "00:02:42,640",
    "end": "00:02:48,480",
    "text": "have been developed. So I tried to keep the technical part as light as I could so that really we,"
  },
  {
    "start": "00:02:48,480",
    "end": "00:02:56,400",
    "text": "I mean, I can focus on the big picture and the questions to be asked and answered. So if you have"
  },
  {
    "start": "00:02:56,400",
    "end": "00:03:02,400",
    "text": "any questions along the way, please feel free to interrupt me either in the chat or by unmuting"
  },
  {
    "start": "00:03:02,400",
    "end": "00:03:09,840",
    "text": "yourselves. So don't worry about leaving the questions till the end. You can interrupt me whenever"
  },
  {
    "start": "00:03:09,840",
    "end": "00:03:14,720",
    "text": "you feel, whenever I say something that doesn't make sense. Hopefully that won't happen too often."
  },
  {
    "start": "00:03:16,880",
    "end": "00:03:23,360",
    "text": "All right, so what is combinatorial configuration? So the best way I think to introduce is with a"
  },
  {
    "start": "00:03:23,360",
    "end": "00:03:30,560",
    "text": "familiar example, which is one player games and the most common one that we use is the 15 puzzle"
  },
  {
    "start": "00:03:30,560",
    "end": "00:03:36,240",
    "text": "game. So for those of you who don't know the 15 puzzle games, so you're given like a 4x4 grid"
  },
  {
    "start": "00:03:37,040",
    "end": "00:03:43,520",
    "text": "and you have one empty square and basically you have all the remaining 15 squares are numbered"
  },
  {
    "start": "00:03:43,520",
    "end": "00:03:50,640",
    "text": "from 1 to 15 and they come in some ordering and your job is to basically move the squares around"
  },
  {
    "start": "00:03:50,640",
    "end": "00:03:57,760",
    "text": "so that all the numbers become ordered. So it's a by-ro so they have to be ordered this way. So if you"
  },
  {
    "start": "00:03:57,760",
    "end": "00:04:04,400",
    "text": "notice in this figure, the only problem is that 14 and 15 are reversed but the only moves that"
  },
  {
    "start": "00:04:04,400",
    "end": "00:04:12,560",
    "text": "you're allowed to do is to basically move a number into the empty square. And basically you have"
  },
  {
    "start": "00:04:12,560",
    "end": "00:04:18,880",
    "text": "to do a sequence of moves so that you get all of the numbers in order. And for those of you who know"
  },
  {
    "start": "00:04:18,880",
    "end": "00:04:26,960",
    "text": "this game, this example that I have on the slide is actually unsolved. There is no way you can"
  },
  {
    "start": "00:04:26,960",
    "end": "00:04:34,000",
    "text": "flip the order in 15 of 14 and 15 in this puzzle. And I have a link here if you want to actually"
  },
  {
    "start": "00:04:34,000",
    "end": "00:04:40,880",
    "text": "play the puzzle online which is pretty fun. So why do I do I start my talk by talking about"
  },
  {
    "start": "00:04:40,880",
    "end": "00:04:47,360",
    "text": "15 puzzle? It's because it's really I mean the way you solve the 15 puzzle tells you a lot about"
  },
  {
    "start": "00:04:47,920",
    "end": "00:04:55,280",
    "text": "the area of combinatorial reconfiguration. So the standard way we would think about the 15 puzzle"
  },
  {
    "start": "00:04:55,280",
    "end": "00:05:00,480",
    "text": "is by looking at the state space or what we call the reconfiguration graph of the 15 puzzle."
  },
  {
    "start": "00:05:01,280",
    "end": "00:05:07,840",
    "text": "So what does that graph consist of? Well, we have one vertex or one node in this graph"
  },
  {
    "start": "00:05:07,840",
    "end": "00:05:14,320",
    "text": "for each possible configuration of the puzzle. So basically each possible configuration so it"
  },
  {
    "start": "00:05:14,320",
    "end": "00:05:19,680",
    "text": "would be a possible permutation of the 15 numbers in addition to where you're going to put the empty"
  },
  {
    "start": "00:05:19,680",
    "end": "00:05:27,760",
    "text": "square. Each one of those will be a vertex in the graph. And now we connect two vertices in that"
  },
  {
    "start": "00:05:27,760",
    "end": "00:05:34,000",
    "text": "graph whenever one can be reached from the other by a single move. And what do we mean here by a"
  },
  {
    "start": "00:05:34,000",
    "end": "00:05:41,360",
    "text": "single mover? It's basically just moving a number into the empty square. So if you look at the top"
  },
  {
    "start": "00:05:41,360",
    "end": "00:05:47,600",
    "text": "node here in this graph, there are four possibilities that you can do in one move which we call"
  },
  {
    "start": "00:05:47,600",
    "end": "00:05:53,040",
    "text": "a reconfiguration step which is you can move nine into the empty square. You can move three into"
  },
  {
    "start": "00:05:53,040",
    "end": "00:06:00,320",
    "text": "the empty square, 12 or 15. And that gives us basically four neighbors of that vertex in the graph."
  },
  {
    "start": "00:06:01,680",
    "end": "00:06:07,440",
    "text": "Okay, and we call this whole graph the reconfiguration graph or the state space if you're more"
  },
  {
    "start": "00:06:07,440",
    "end": "00:06:15,440",
    "text": "comfortable thinking about states, the states of the game. So now given this graph, the reconfiguration"
  },
  {
    "start": "00:06:15,440",
    "end": "00:06:21,200",
    "text": "graph, there are tons of very interesting questions that you can ask about it. There are structural"
  },
  {
    "start": "00:06:21,200",
    "end": "00:06:26,960",
    "text": "questions and there are algorithms to make questions. And these are typically the types of questions"
  },
  {
    "start": "00:06:26,960",
    "end": "00:06:35,040",
    "text": "that we're interested in in this area of combinatorial reconfiguration. So a couple of examples of"
  },
  {
    "start": "00:06:35,040",
    "end": "00:06:41,040",
    "text": "structural questions would be, well, the simplest one would be how big is this reconfiguration graph?"
  },
  {
    "start": "00:06:41,040",
    "end": "00:06:48,480",
    "text": "Right? How many vertices or how many edges? And that's usually not a very hard question to answer"
  },
  {
    "start": "00:06:48,560",
    "end": "00:06:54,640",
    "text": "in terms of upper and lower ones. More interestingly, you could ask, is this reconfiguration graph"
  },
  {
    "start": "00:06:54,640",
    "end": "00:07:01,680",
    "text": "connected? Right? Or is, can I reach any state starting from any other state by a sequence of"
  },
  {
    "start": "00:07:01,680",
    "end": "00:07:08,800",
    "text": "legal moves? And as I told you before, for the 15 puzzle, the reconfiguration graph is definitely"
  },
  {
    "start": "00:07:08,800",
    "end": "00:07:15,040",
    "text": "not connected because there was no way to reverse 14 and 15 in the previous example that I showed"
  },
  {
    "start": "00:07:15,120",
    "end": "00:07:20,400",
    "text": "you and you can easily prove that, by the way. So when it's not connected, another question would be"
  },
  {
    "start": "00:07:20,400",
    "end": "00:07:28,880",
    "text": "how many components does it have? Is there some sort of a nice structure to the components of this graph?"
  },
  {
    "start": "00:07:30,000",
    "end": "00:07:35,200",
    "text": "And then another question would be what is the diameter of the circumfiguration graph or of"
  },
  {
    "start": "00:07:35,200",
    "end": "00:07:39,680",
    "text": "each one of its components? And that's usually a very important question to ask when you're dealing with"
  },
  {
    "start": "00:07:39,680",
    "end": "00:07:46,880",
    "text": "one player games because this could tell you like what would be the worst possible shortest path"
  },
  {
    "start": "00:07:46,880",
    "end": "00:07:51,600",
    "text": "to reach a target configuration or to solve your game, to win your game, for example."
  },
  {
    "start": "00:07:52,160",
    "end": "00:07:58,160",
    "text": "And in the literature, this is sometimes known as God's number, which would be the diameter of"
  },
  {
    "start": "00:07:58,160",
    "end": "00:08:04,400",
    "text": "the reconfiguration graph. And these are all very interesting, very interesting structural questions"
  },
  {
    "start": "00:08:04,480",
    "end": "00:08:11,680",
    "text": "to ask about this reconfiguration graph. Now on the algorithmic side or the computational side,"
  },
  {
    "start": "00:08:11,680",
    "end": "00:08:18,320",
    "text": "there's the obvious question of if I'm given a starting state and some ending state or target state,"
  },
  {
    "start": "00:08:18,320",
    "end": "00:08:23,520",
    "text": "like in the case of the puzzle game, that I am given some starting state and we know what the"
  },
  {
    "start": "00:08:23,520",
    "end": "00:08:29,520",
    "text": "goal state is. So here one decision problem would be to answer the question whether it's possible to"
  },
  {
    "start": "00:08:29,600",
    "end": "00:08:34,320",
    "text": "get to the target state starting from some initial state that is also given to me."
  },
  {
    "start": "00:08:35,840",
    "end": "00:08:40,320",
    "text": "So you can decide to solve this problem either as a decision problem or as a search problem,"
  },
  {
    "start": "00:08:40,320",
    "end": "00:08:45,920",
    "text": "which would give you the actual sequence of steps that will take you from a state to the target state."
  },
  {
    "start": "00:08:49,760",
    "end": "00:08:55,520",
    "text": "Other interesting computational problems is it always possible to go from one configuration to"
  },
  {
    "start": "00:08:55,600",
    "end": "00:09:01,200",
    "text": "any other and this is basically also related to the structural question about connected components."
  },
  {
    "start": "00:09:02,400",
    "end": "00:09:09,120",
    "text": "And the last question that I will mention, which is also interesting, is how fast can you go"
  },
  {
    "start": "00:09:09,120",
    "end": "00:09:13,680",
    "text": "from one configuration to another? Meaning can you do it in at most case steps?"
  },
  {
    "start": "00:09:14,560",
    "end": "00:09:20,400",
    "text": "There is a question I should wait or no."
  },
  {
    "start": "00:09:25,280",
    "end": "00:09:33,520",
    "text": "All right. So think about all of these questions that we paused using the simple 15 puzzle game."
  },
  {
    "start": "00:09:34,080",
    "end": "00:09:40,160",
    "text": "And now we're going to look at a lot of other possible problems where the same"
  },
  {
    "start": "00:09:40,160",
    "end": "00:09:45,760",
    "text": "any configuration graph can be extracted. And we can ask the same set of questions."
  },
  {
    "start": "00:09:46,800",
    "end": "00:09:52,400",
    "text": "So all of you here are familiar with the case sad problem. So you're given a Boolean formula and"
  },
  {
    "start": "00:09:52,400",
    "end": "00:09:58,960",
    "text": "you want to know if you can satisfy this formula by assigning values to the variables. And we know"
  },
  {
    "start": "00:09:58,960",
    "end": "00:10:04,880",
    "text": "that this is NP complete for K greater than or equal to three. So now how can you transform this"
  },
  {
    "start": "00:10:04,880",
    "end": "00:10:10,080",
    "text": "into a reconfiguration problem? Well, it's very simple. So now you're given a formula"
  },
  {
    "start": "00:10:11,440",
    "end": "00:10:16,720",
    "text": "and you're given two satisfying assignments. So you can think of those satisfying assignments as"
  },
  {
    "start": "00:10:16,720",
    "end": "00:10:24,480",
    "text": "bit vectors. And so now the question that you can ask is can I go from the first satisfying assignment"
  },
  {
    "start": "00:10:24,480",
    "end": "00:10:32,800",
    "text": "as to the next one? By basically flipping one bit at a time, under the condition that I remain"
  },
  {
    "start": "00:10:32,800",
    "end": "00:10:39,200",
    "text": "a satisfying assignment at all times. And notice that without this condition, the problem is trivial."
  },
  {
    "start": "00:10:40,880",
    "end": "00:10:48,080",
    "text": "So you can basically just flip the bits however you like and reach S from T or T from S. But once"
  },
  {
    "start": "00:10:48,080",
    "end": "00:10:54,400",
    "text": "you add this constraint of you should remain a satisfying assignment, the problem becomes way"
  },
  {
    "start": "00:10:54,400",
    "end": "00:11:01,520",
    "text": "more interesting. And you can think of this problem again as walking in the solution space of the"
  },
  {
    "start": "00:11:01,600",
    "end": "00:11:11,520",
    "text": "given formula of all the satisfying assignment of the formula. All right, so that's the sad reconfiguration"
  },
  {
    "start": "00:11:11,520",
    "end": "00:11:20,400",
    "text": "problem. Let's look at another example. Graph coloring. We all know it. We all love it. You're"
  },
  {
    "start": "00:11:20,400",
    "end": "00:11:26,320",
    "text": "given a graph and some integer K and you are asked whether you can properly take color the"
  },
  {
    "start": "00:11:26,320",
    "end": "00:11:30,560",
    "text": "graph G. And we know again that this is NP complete for K greater than or equal to three."
  },
  {
    "start": "00:11:31,120",
    "end": "00:11:36,800",
    "text": "How do you transform that into a reconfiguration problem? Well, now you're given a graph,"
  },
  {
    "start": "00:11:36,800",
    "end": "00:11:44,000",
    "text": "you're given two colorings of the graph, alpha and beta. And the question is can you recolor alpha"
  },
  {
    "start": "00:11:44,000",
    "end": "00:11:51,040",
    "text": "to get the to beta? But you need to recolor one vertex at a time and you need to remain a proper"
  },
  {
    "start": "00:11:51,040",
    "end": "00:11:58,640",
    "text": "K coloring throughout. Same idea again leads us to this notion of the reconfiguration space"
  },
  {
    "start": "00:11:58,640",
    "end": "00:12:03,360",
    "text": "where we are looking at the K colorings of the graph and how they are connected"
  },
  {
    "start": "00:12:04,320",
    "end": "00:12:09,200",
    "text": "under this adjacent simulation that we define, which is a single vertex recoloring."
  },
  {
    "start": "00:12:11,920",
    "end": "00:12:17,280",
    "text": "The final example that I will mention, which will be basically what we will focus on in the rest of"
  },
  {
    "start": "00:12:17,280",
    "end": "00:12:23,440",
    "text": "the talk is token placement. I call it, but as you will all guess, this is the famous independent"
  },
  {
    "start": "00:12:23,440",
    "end": "00:12:29,360",
    "text": "set problem. But we will look at it as a token placement problem because it will be more useful"
  },
  {
    "start": "00:12:29,360",
    "end": "00:12:34,080",
    "text": "for the rest of the talk. So you're given a graph G and an integer K. And the question is,"
  },
  {
    "start": "00:12:34,080",
    "end": "00:12:40,640",
    "text": "can you place K tokens on your graph K black tokens so that no two of these tokens share an edge."
  },
  {
    "start": "00:12:40,640",
    "end": "00:12:46,640",
    "text": "And of course, we all know that this is an NP complete problem. So how can you transform this"
  },
  {
    "start": "00:12:46,640",
    "end": "00:12:52,480",
    "text": "problem into a reconfiguration problem? Again, now I'm giving a graph two independent sets of the graph."
  },
  {
    "start": "00:12:54,160",
    "end": "00:12:58,800",
    "text": "Each of size K. And the question is, can I go from one independent set to the other"
  },
  {
    "start": "00:13:00,320",
    "end": "00:13:07,440",
    "text": "under what rule? So here defining the rule for independent set, how can I go between consecutive"
  },
  {
    "start": "00:13:07,440",
    "end": "00:13:14,160",
    "text": "independent sets becomes a little bit less obvious. And there are two main strategies that people"
  },
  {
    "start": "00:13:14,160",
    "end": "00:13:21,040",
    "text": "have attempted. So the first rule is what we call token jumping. So you are basically allowed to"
  },
  {
    "start": "00:13:21,040",
    "end": "00:13:27,760",
    "text": "take any token on your graph and jump it to any other vertex on the graph, assuming that it doesn't"
  },
  {
    "start": "00:13:27,760",
    "end": "00:13:35,760",
    "text": "have a token and that you maintain an independent set at all times. So for example, in this example that"
  },
  {
    "start": "00:13:35,760",
    "end": "00:13:41,840",
    "text": "I have here, it would be perfectly okay to take this token here and jump it to this vertex here."
  },
  {
    "start": "00:13:41,840",
    "end": "00:13:52,080",
    "text": "Or I could also take this token here and jump it to this vertex here. So that, no, actually that"
  },
  {
    "start": "00:13:52,080",
    "end": "00:13:59,280",
    "text": "would violate the independence. So you can jump to any other vertex as long as you maintain independence."
  },
  {
    "start": "00:13:59,280",
    "end": "00:14:06,720",
    "text": "And we call that the token jumping rule. The other rule is basically token sliding. So in this case,"
  },
  {
    "start": "00:14:06,720",
    "end": "00:14:15,920",
    "text": "we only allow a token to slide along edges of the graph. So a token can only move to adjacent"
  },
  {
    "start": "00:14:15,920",
    "end": "00:14:22,560",
    "text": "vertex, assuming of course, this does not violate independence. So now we have two different"
  },
  {
    "start": "00:14:22,560",
    "end": "00:14:27,360",
    "text": "reconfiguration graphs we can think about. We can think about the reconfiguration graph under the"
  },
  {
    "start": "00:14:27,360",
    "end": "00:14:32,800",
    "text": "token jumping adjacency. And we can think about the reconfiguration graph under the token sliding"
  },
  {
    "start": "00:14:32,800",
    "end": "00:14:39,120",
    "text": "adjacency. And we're going to talk about these two different problems because they do actually"
  },
  {
    "start": "00:14:39,120",
    "end": "00:14:46,000",
    "text": "behave quite differently and they produce quite interesting results like the difference between the two."
  },
  {
    "start": "00:14:46,000",
    "end": "00:14:51,840",
    "text": "We don't fully understand yet, but we kind of know that token sliding can be harder than token"
  },
  {
    "start": "00:14:51,840",
    "end": "00:15:00,560",
    "text": "jumping. But there's still a lot of questions to be answered. All right. So some of you might be asking,"
  },
  {
    "start": "00:15:00,560",
    "end": "00:15:08,480",
    "text": "why do we care about studying such problems? There's a lot of motivations out there. I mean,"
  },
  {
    "start": "00:15:09,600",
    "end": "00:15:15,120",
    "text": "sometimes I would say you don't need motivation. They're interesting. There's a lot of open"
  },
  {
    "start": "00:15:15,120",
    "end": "00:15:20,720",
    "text": "questions that we need to answer. But you can also think about reconfiguration problems as another"
  },
  {
    "start": "00:15:20,720",
    "end": "00:15:26,560",
    "text": "way of modeling real world algorithmic problems because you usually never start from scratch."
  },
  {
    "start": "00:15:27,120",
    "end": "00:15:32,080",
    "text": "When you're trying to solve real world problems, you usually start from something and you're trying"
  },
  {
    "start": "00:15:32,080",
    "end": "00:15:37,760",
    "text": "to prove it or make it better or change it to something more appropriate. Another very good"
  },
  {
    "start": "00:15:38,640",
    "end": "00:15:44,720",
    "text": "application of studying these problems is that they give you a better understanding of solution"
  },
  {
    "start": "00:15:44,720",
    "end": "00:15:50,960",
    "text": "spaces, which can be very important for other areas as well. And they have been used in statistical"
  },
  {
    "start": "00:15:50,960",
    "end": "00:15:57,520",
    "text": "physics, quantum computing, any complexity theory, combinatorics, and robotics, and hopefully many more"
  },
  {
    "start": "00:15:57,520",
    "end": "00:16:03,200",
    "text": "applications to come. But what I would tell you is that there are so many very interesting problems"
  },
  {
    "start": "00:16:03,200",
    "end": "00:16:08,800",
    "text": "that are so easy to start thinking about without having too much background, which is what I think"
  },
  {
    "start": "00:16:08,800",
    "end": "00:16:15,120",
    "text": "this is a very nice area to start working on at any level in your research career."
  },
  {
    "start": "00:16:15,200",
    "end": "00:16:25,200",
    "text": "All right, so I'll take a break here and take questions if there are any. And then we will dive into"
  },
  {
    "start": "00:16:25,200",
    "end": "00:16:32,640",
    "text": "the token jumping and token sliding problems, what we know about them in terms of classical complexity,"
  },
  {
    "start": "00:16:32,640",
    "end": "00:16:37,280",
    "text": "and what was basically the starting point for the project that led us to this paper."
  },
  {
    "start": "00:16:37,760",
    "end": "00:16:41,920",
    "text": "Any questions at this point?"
  },
  {
    "start": "00:16:45,200",
    "end": "00:16:51,600",
    "text": "I'm, I apologize for the small context, which I am in interrupting here. So this is just to"
  },
  {
    "start": "00:16:51,600",
    "end": "00:16:57,680",
    "text": "announce for the PC301 workshop that will be happening in December end. And this will be slightly"
  },
  {
    "start": "00:16:57,680",
    "end": "00:17:03,120",
    "text": "different from the previous two workshops. First major difference, this will be online. Second is"
  },
  {
    "start": "00:17:03,760",
    "end": "00:17:11,840",
    "text": "some advanced topics, what we discuss. So anyone who intends to explore somewhat more complex"
  },
  {
    "start": "00:17:11,840",
    "end": "00:17:18,480",
    "text": "topics in parametrize algorithms is invited to have a check. They can look at the website that"
  },
  {
    "start": "00:17:18,480",
    "end": "00:17:23,200",
    "text": "has been shared on the chat. And if you wish, you can register simply by filling a form that is"
  },
  {
    "start": "00:17:24,400",
    "end": "00:17:30,480",
    "text": "linked at the bottom of the webpage. So just to inform you all about it. And sorry for the"
  },
  {
    "start": "00:17:30,480",
    "end": "00:17:42,000",
    "text": "introduction for this now. All right. All right. So let's start talking about token jumping,"
  },
  {
    "start": "00:17:42,000",
    "end": "00:17:48,080",
    "text": "token sliding, and a little bit about classical complexity. I know everybody here knows about"
  },
  {
    "start": "00:17:48,080",
    "end": "00:17:53,120",
    "text": "P and NPs. So I'm not going to talk about this. Some of you might not be familiar with the"
  },
  {
    "start": "00:17:53,120",
    "end": "00:17:59,520",
    "text": "P space class. So just a quick note that's as much as you will need to know for this talk is that"
  },
  {
    "start": "00:17:59,520",
    "end": "00:18:05,840",
    "text": "P space is the set of all decision problems that can be solved using a polynomial amount of space."
  },
  {
    "start": "00:18:06,720",
    "end": "00:18:13,360",
    "text": "And the reason why I mentioned this class is because many many many many the configuration problem"
  },
  {
    "start": "00:18:13,360",
    "end": "00:18:20,400",
    "text": "actually are P space complete. Okay. And so so what we know the standard inclusion is we know that"
  },
  {
    "start": "00:18:20,400",
    "end": "00:18:26,480",
    "text": "P is contained in NP, which is contained in P space. But a very useful thing about P space is"
  },
  {
    "start": "00:18:26,480",
    "end": "00:18:34,080",
    "text": "that savage prove that it's equal to NP space. So polynomial space and non deterministic polynomial"
  },
  {
    "start": "00:18:34,080",
    "end": "00:18:41,040",
    "text": "space are the same class. Basically, and that's extremely useful when you start to think about"
  },
  {
    "start": "00:18:41,040",
    "end": "00:18:45,760",
    "text": "reconfiguration problems because if you think about reconfiguration problem where you're given some"
  },
  {
    "start": "00:18:45,760",
    "end": "00:18:53,520",
    "text": "state and you want to reach the other one. So basically you can solve that easily and non deterministic"
  },
  {
    "start": "00:18:53,520",
    "end": "00:19:02,400",
    "text": "polynomial space, which basically implies that they are NP space. But actually you can show a lot"
  },
  {
    "start": "00:19:02,400",
    "end": "00:19:08,160",
    "text": "more than that. You can show that many really many reconfiguration problems are actually P space"
  },
  {
    "start": "00:19:08,160",
    "end": "00:19:13,760",
    "text": "complete, which is not surprising. Right. The fact that many of these reconfiguration problems are"
  },
  {
    "start": "00:19:13,760",
    "end": "00:19:22,640",
    "text": "P space complete is not very surprising. Right. And then not being in NP is because they don't always"
  },
  {
    "start": "00:19:22,640",
    "end": "00:19:28,560",
    "text": "have polynomial size certificates, which also makes sense because sometimes the number of steps"
  },
  {
    "start": "00:19:28,560",
    "end": "00:19:34,080",
    "text": "that you need to take to go from one configuration to the other might very well be exponential in the"
  },
  {
    "start": "00:19:34,080",
    "end": "00:19:41,120",
    "text": "graph. But there are also some extremely surprising results. And these are some of the results some of"
  },
  {
    "start": "00:19:41,120",
    "end": "00:19:48,640",
    "text": "my favorite results in the area. So for example, you all know that coloring is NP complete even for"
  },
  {
    "start": "00:19:48,880",
    "end": "00:19:56,320",
    "text": "K equals three. However, it turns out that if you try to solve the recoloring problem for K equals"
  },
  {
    "start": "00:19:56,320",
    "end": "00:20:02,640",
    "text": "three, it's actually polynomial time solvable. So if I give you two three colorings of a graph and"
  },
  {
    "start": "00:20:02,640",
    "end": "00:20:09,680",
    "text": "I ask you, is there a path between them that recolors one vertex at a time and never is and is"
  },
  {
    "start": "00:20:09,680",
    "end": "00:20:15,840",
    "text": "always a valid three coloring, then this problem can be solved in polynomial time. And the recoloring"
  },
  {
    "start": "00:20:15,840",
    "end": "00:20:23,600",
    "text": "problem only becomes P space complete for K equals four and more. Right. So that's the first"
  },
  {
    "start": "00:20:24,480",
    "end": "00:20:31,760",
    "text": "surprising result. Another very surprising result is that as as your all FBT experts here, I know"
  },
  {
    "start": "00:20:31,760",
    "end": "00:20:37,440",
    "text": "that you're all familiar with the fact that usually when we study problems on graphs of bounded bucket"
  },
  {
    "start": "00:20:37,760",
    "end": "00:20:46,080",
    "text": "path with tree width, they tend to become easier. It turns out that that's not really the case"
  },
  {
    "start": "00:20:46,800",
    "end": "00:20:51,360",
    "text": "for reconfiguration problems, at least for token sliding and jumping, which is the two problems"
  },
  {
    "start": "00:20:51,360",
    "end": "00:20:57,280",
    "text": "that are related to independent set. It turns out that those two problems remain P space complete"
  },
  {
    "start": "00:20:57,280",
    "end": "00:21:03,440",
    "text": "even if you have a graph of constant tree width or path width or even bucket width. So a very,"
  },
  {
    "start": "00:21:03,440",
    "end": "00:21:08,640",
    "text": "very, very simple graph structure still the problem remains hard."
  },
  {
    "start": "00:21:11,120",
    "end": "00:21:18,560",
    "text": "All right. And finally, the last theorem that I also like a lot shows you basically that"
  },
  {
    "start": "00:21:18,560",
    "end": "00:21:26,160",
    "text": "sliding and jumping behave differently. And it was shown that if you restrict yourself to"
  },
  {
    "start": "00:21:26,160",
    "end": "00:21:31,440",
    "text": "bipartite graphs, where we know that max and independent set can be solved in polynomial time,"
  },
  {
    "start": "00:21:32,240",
    "end": "00:21:38,560",
    "text": "if you restrict yourself to those graphs, it turns out that token jumping is NP complete,"
  },
  {
    "start": "00:21:39,760",
    "end": "00:21:46,400",
    "text": "whereas token sliding is P space complete, which is a which is a strange"
  },
  {
    "start": "00:21:48,480",
    "end": "00:21:50,880",
    "text": "difference between the behavior of those two problems."
  },
  {
    "start": "00:21:54,240",
    "end": "00:21:54,640",
    "text": "All right."
  },
  {
    "start": "00:21:55,120",
    "end": "00:22:04,080",
    "text": "So in fact, we know a lot more about token sliding and token jumping. These problems have been"
  },
  {
    "start": "00:22:04,080",
    "end": "00:22:08,960",
    "text": "at the heart of the area of combinatorial reconfiguration. They have been studied so much."
  },
  {
    "start": "00:22:09,920",
    "end": "00:22:15,120",
    "text": "And we know so much about them at least in terms of standard or classical complexity."
  },
  {
    "start": "00:22:15,680",
    "end": "00:22:22,160",
    "text": "So some of the important results for our paper that we're going to focus on"
  },
  {
    "start": "00:22:22,880",
    "end": "00:22:30,080",
    "text": "is this result. So that's going to be the starting point of the results that we will discuss"
  },
  {
    "start": "00:22:30,080",
    "end": "00:22:35,040",
    "text": "next when we move to parametrize complexity. So the fact that token sliding and token jumping"
  },
  {
    "start": "00:22:36,640",
    "end": "00:22:41,520",
    "text": "are b space complete and then NP complete respectively on bipartite graphs was the starting"
  },
  {
    "start": "00:22:41,520",
    "end": "00:22:46,320",
    "text": "point of our next paper. But there are some very interesting results here that are also worth"
  },
  {
    "start": "00:22:46,320",
    "end": "00:22:51,600",
    "text": "mentioning. So for example, for even whole figure halves, we know how to solve token jumping"
  },
  {
    "start": "00:22:51,600",
    "end": "00:22:58,240",
    "text": "in polynomial time. But the complexity of independent set even remains open on this class of graphs."
  },
  {
    "start": "00:22:59,600",
    "end": "00:23:05,360",
    "text": "And the complexity of token sliding also remains open. So we don't know how to check if given"
  },
  {
    "start": "00:23:05,360",
    "end": "00:23:11,440",
    "text": "two independent sets, I can slide one to the other. Can you answer that question in polynomial"
  },
  {
    "start": "00:23:11,440",
    "end": "00:23:18,880",
    "text": "time for even whole free graphs? For split graphs and chordal graphs, they also behave"
  },
  {
    "start": "00:23:18,880",
    "end": "00:23:24,320",
    "text": "extremely differently token sliding and token jumping. So they are token sliding is p space"
  },
  {
    "start": "00:23:24,320",
    "end": "00:23:29,600",
    "text": "complete on split graphs and chordal graphs while token jumping is polynomial time."
  },
  {
    "start": "00:23:30,800",
    "end": "00:23:38,160",
    "text": "And that is some of the reasons why we feel that token sliding is harder usually than token jumping."
  },
  {
    "start": "00:23:38,160",
    "end": "00:23:48,480",
    "text": "But it's not always the case. All right. So that's it for classical complexity."
  },
  {
    "start": "00:23:49,840",
    "end": "00:23:55,920",
    "text": "So now let's move on to parameterized complexity. And let's basically think about how you can"
  },
  {
    "start": "00:23:55,920",
    "end": "00:24:04,080",
    "text": "parameterize those two problems, token jumping and token sliding. So the obvious parameter would be"
  },
  {
    "start": "00:24:04,080",
    "end": "00:24:09,280",
    "text": "the number of tokens. So one of the obvious parameters would be the number of tokens. So"
  },
  {
    "start": "00:24:10,320",
    "end": "00:24:15,440",
    "text": "and we're going to denote that by K. Another parameter would be the length of the sequence."
  },
  {
    "start": "00:24:15,440",
    "end": "00:24:20,000",
    "text": "Like how many steps does it take to go from one independent set to the other?"
  },
  {
    "start": "00:24:20,880",
    "end": "00:24:25,600",
    "text": "You can also obviously parameterize by tree width or path width or any combination of the above."
  },
  {
    "start": "00:24:26,880",
    "end": "00:24:34,080",
    "text": "When we started working on this problem, our initial aim was to basically study the"
  },
  {
    "start": "00:24:34,080",
    "end": "00:24:40,160",
    "text": "parameterized complexity of token sliding and token jumping on bipartite graphs using the parameter"
  },
  {
    "start": "00:24:40,160",
    "end": "00:24:46,320",
    "text": "K number of tokens. Right? Because remember, we saw that token sliding is piece-based"
  },
  {
    "start": "00:24:46,320",
    "end": "00:24:53,120",
    "text": "complete on bipartite graphs and token jumping is NP. So you were interested to see if basically"
  },
  {
    "start": "00:24:53,120",
    "end": "00:24:59,120",
    "text": "this is going to give us W1 hardness for token sliding and FPTNES for token jumping."
  },
  {
    "start": "00:25:00,800",
    "end": "00:25:05,440",
    "text": "All right. At least that was the initial hope. That's why we started working on this project."
  },
  {
    "start": "00:25:06,160",
    "end": "00:25:12,000",
    "text": "We weren't able to answer the two questions. So we were able to answer one side of the question,"
  },
  {
    "start": "00:25:12,720",
    "end": "00:25:20,720",
    "text": "which is we were able to show that on bipartite graphs, token sliding is in fact W1 hardness."
  },
  {
    "start": "00:25:22,320",
    "end": "00:25:28,160",
    "text": "So token sliding parameterized by the number of tokens on bipartite graphs is W1 hard."
  },
  {
    "start": "00:25:28,720",
    "end": "00:25:35,120",
    "text": "We were not able to answer the question for token jumping. So that is still an open question."
  },
  {
    "start": "00:25:36,000",
    "end": "00:25:42,800",
    "text": "So having answered that question and failed on the next question, we started thinking about ways"
  },
  {
    "start": "00:25:42,800",
    "end": "00:25:49,760",
    "text": "to basically simplify a little bit some of these questions. So the next thing we asked ourselves,"
  },
  {
    "start": "00:25:49,760",
    "end": "00:25:56,320",
    "text": "so there are two directions where you can try and simplify. So the next thing we asked"
  },
  {
    "start": "00:25:56,320",
    "end": "00:26:02,480",
    "text": "ourselves was, okay, so from bipartite graphs, how can I go to other classes of graphs"
  },
  {
    "start": "00:26:03,200",
    "end": "00:26:11,200",
    "text": "and see where token jumping becomes hard or easy? And it turned out that if you basically exclude"
  },
  {
    "start": "00:26:11,200",
    "end": "00:26:21,120",
    "text": "only C4 from your graph, right? And so we, because in bipartite graphs, you're excluding all odd cycles."
  },
  {
    "start": "00:26:22,640",
    "end": "00:26:28,160",
    "text": "Right. So, and we started thinking about what kinds of cycles affect the behavior of those"
  },
  {
    "start": "00:26:28,160",
    "end": "00:26:33,520",
    "text": "problems? So the first question was, what about C4 free graphs? And it turned out that both"
  },
  {
    "start": "00:26:33,520",
    "end": "00:26:42,720",
    "text": "problems remained W1 hard on C4 free graphs. Now, if you exclude C3 and C4, it turns out that"
  },
  {
    "start": "00:26:42,720",
    "end": "00:26:49,920",
    "text": "token jumping becomes FPD has an order K squared kernel. But for token sliding, we were not able"
  },
  {
    "start": "00:26:50,560",
    "end": "00:26:57,760",
    "text": "to determine the complexity. Now, if you go to the other side of that,"
  },
  {
    "start": "00:26:58,400",
    "end": "00:27:07,280",
    "text": "so what if we enforce both bipartiteness as well as C4 freeness? So in that case, we were able to"
  },
  {
    "start": "00:27:07,280",
    "end": "00:27:16,880",
    "text": "show that both problems became FPD. Okay. And basically, the bipartite bounded degree graphs was"
  },
  {
    "start": "00:27:16,880",
    "end": "00:27:25,200",
    "text": "just a stepping stone to get to the bipartite C4 free graph result. So let me, let me repeat that"
  },
  {
    "start": "00:27:25,200",
    "end": "00:27:30,880",
    "text": "maybe slightly more clearly. So after basically answering the first question, which was bipartite"
  },
  {
    "start": "00:27:30,880",
    "end": "00:27:36,160",
    "text": "graphs, we were able to show that token sliding was W1 hard, but we were not able to determine"
  },
  {
    "start": "00:27:36,160",
    "end": "00:27:43,120",
    "text": "the complexity of token jumping. So then we went to C4 free graphs and we were able to show that both"
  },
  {
    "start": "00:27:43,120",
    "end": "00:27:50,640",
    "text": "problems are actually W1 hard. Then if we added one more constraint, which was C3 C4 free graphs,"
  },
  {
    "start": "00:27:50,640",
    "end": "00:27:55,280",
    "text": "we got FPDness for token jumping, but it remained open for token sliding."
  },
  {
    "start": "00:27:56,400",
    "end": "00:28:02,960",
    "text": "And on the other side of the spectrum, so if we keep bipartite and enforce the C4 freeness,"
  },
  {
    "start": "00:28:02,960",
    "end": "00:28:13,760",
    "text": "we get FPD for both problems. And as a side note, this blue result is not part of our paper. This"
  },
  {
    "start": "00:28:13,760",
    "end": "00:28:22,880",
    "text": "was known prior to our paper. So any questions about the results?"
  },
  {
    "start": "00:28:22,880",
    "end": "00:28:49,200",
    "text": "No questions. All right. Cool. So lots of open problems. The first and obvious one is,"
  },
  {
    "start": "00:28:49,840",
    "end": "00:28:54,640",
    "text": "what is the pattern is token jumping FPD, parameterized by K on bipartite graphs."
  },
  {
    "start": "00:28:55,280",
    "end": "00:29:01,360",
    "text": "And that's really, I mean, that was the initial question that we set out to answer and couldn't."
  },
  {
    "start": "00:29:01,360",
    "end": "00:29:12,640",
    "text": "So that remains open. And it's, so I will not be going over the hardness reduction for token sliding"
  },
  {
    "start": "00:29:12,640",
    "end": "00:29:18,320",
    "text": "on bipartite graphs because it's quite technical. I don't feel a talk is the right place to go over it."
  },
  {
    "start": "00:29:19,520",
    "end": "00:29:27,120",
    "text": "But if you go over the reduction, you will see that that it's the two problems really behave"
  },
  {
    "start": "00:29:27,120",
    "end": "00:29:32,240",
    "text": "differently. And there that doesn't seem to be a chance to basically make the same type of"
  },
  {
    "start": "00:29:32,240",
    "end": "00:29:39,920",
    "text": "reduction work for token jumping. So the second interesting open question is, how about token jumping"
  },
  {
    "start": "00:29:39,920",
    "end": "00:29:45,920",
    "text": "parameterized by K on triangle free graphs? That's basically even more general than question one."
  },
  {
    "start": "00:29:46,880",
    "end": "00:29:53,360",
    "text": "Right. So, and the reason why I mentioned this question separately is because almost every reduction"
  },
  {
    "start": "00:29:53,360",
    "end": "00:30:01,280",
    "text": "that I know of includes large clicks. So you need to use large clicks in your reductions. So how about"
  },
  {
    "start": "00:30:01,280",
    "end": "00:30:08,080",
    "text": "if we don't allow triangle and large clicks? So can we can we can we then say something about the problem?"
  },
  {
    "start": "00:30:08,960",
    "end": "00:30:16,320",
    "text": "So that's for token jumping. Now, when it when you go to token sliding. So, so the open problem is"
  },
  {
    "start": "00:30:17,280",
    "end": "00:30:23,520",
    "text": "what happens for token sliding on graphs of girth at least five, so if they are C3, C4 free."
  },
  {
    "start": "00:30:24,240",
    "end": "00:30:31,440",
    "text": "Or you can even make that a bit weaker and ask for any girth of at least P for some constant P."
  },
  {
    "start": "00:30:33,840",
    "end": "00:30:37,200",
    "text": "And for all of these questions, of course, polynomial kernels."
  },
  {
    "start": "00:30:38,560",
    "end": "00:30:44,800",
    "text": "Would be interesting as well because in our case, we do get polynomial kernels for the FB."
  },
  {
    "start": "00:30:47,600",
    "end": "00:30:53,360",
    "text": "And the polynomials are not great, but polynomial regardless."
  },
  {
    "start": "00:30:56,640",
    "end": "00:31:03,680",
    "text": "All right. So, in the rest of the talk, I will try to cover some of the technical stuff."
  },
  {
    "start": "00:31:03,680",
    "end": "00:31:09,360",
    "text": "And as promised, I will try to keep it as light as possible so that I can give you some of a lot"
  },
  {
    "start": "00:31:09,360",
    "end": "00:31:15,920",
    "text": "of the intuition and techniques that are used in this paper and that are generally used when"
  },
  {
    "start": "00:31:15,920",
    "end": "00:31:22,160",
    "text": "dealing with reconfiguration problems. So the first result that we will go over is this W hardness"
  },
  {
    "start": "00:31:22,160",
    "end": "00:31:28,560",
    "text": "on C4 free graphs. Right. For both token sliding and token jumping. It's the same reduction and"
  },
  {
    "start": "00:31:29,520",
    "end": "00:31:35,600",
    "text": "you will get both results because we will be using maximum independent sets."
  },
  {
    "start": "00:31:36,480",
    "end": "00:31:43,120",
    "text": "So if you're trying to basically do token sliding from one maximum independent set to the other,"
  },
  {
    "start": "00:31:43,760",
    "end": "00:31:48,880",
    "text": "or token jumping, these two rules become equivalent. Jumping becomes equivalent to sliding."
  },
  {
    "start": "00:31:49,520",
    "end": "00:31:54,400",
    "text": "So when you're dealing with maximum independent sets, these two basically rules are the same."
  },
  {
    "start": "00:31:55,360",
    "end": "00:31:59,440",
    "text": "And that's what we're going to do. But what we're going to prove actually is a stronger"
  },
  {
    "start": "00:31:59,440",
    "end": "00:32:05,200",
    "text": "theorem. What we're going to prove is the following theorem. If you take any p greater than or"
  },
  {
    "start": "00:32:05,200",
    "end": "00:32:15,200",
    "text": "equal to four, then both problems are W hard on C4, C5 dot dot dot up to CP free graphs,"
  },
  {
    "start": "00:32:15,920",
    "end": "00:32:27,120",
    "text": "which implies of course C4 free graphs. But you can basically exclude any cycles from C4 up to CP"
  },
  {
    "start": "00:32:27,120",
    "end": "00:32:30,640",
    "text": "for constant P and the problems will remain W1 hard."
  },
  {
    "start": "00:32:36,960",
    "end": "00:32:43,520",
    "text": "So how do we prove this result? In fact, we use a known reduction from a problem known as grid"
  },
  {
    "start": "00:32:43,520",
    "end": "00:32:51,440",
    "text": "tiling, which is a W1 hard problem. And grid tiling is reduced to the independent set problem"
  },
  {
    "start": "00:32:51,440",
    "end": "00:33:00,320",
    "text": "on C4 up to CP free graphs. And that reduction was used to show that independent set remains"
  },
  {
    "start": "00:33:00,320",
    "end": "00:33:09,360",
    "text": "W1 hard if you exclude C4 up to CP for any constant P. But what is interesting and useful in that"
  },
  {
    "start": "00:33:09,360",
    "end": "00:33:16,160",
    "text": "reduction is the graph that is obtained from the reduction. So the graph that is obtained from"
  },
  {
    "start": "00:33:16,160",
    "end": "00:33:22,640",
    "text": "the reduction has three properties that are going to be useful to us. The first property is that"
  },
  {
    "start": "00:33:22,640",
    "end": "00:33:31,680",
    "text": "you can partition the graph into basically 8k squared into P plus 1 clicks. So you have a bunch of"
  },
  {
    "start": "00:33:31,680",
    "end": "00:33:36,880",
    "text": "clicks each of size n and all of the edges basically are between the clicks."
  },
  {
    "start": "00:33:38,960",
    "end": "00:33:44,560",
    "text": "But that's it, that's it, that's the whole of the graph. It's a bunch of clicks and edges between them."
  },
  {
    "start": "00:33:45,680",
    "end": "00:33:52,480",
    "text": "Of course, the more important property as well here is that this graph is going to be C4 up to CP free."
  },
  {
    "start": "00:33:52,880",
    "end": "00:34:03,040",
    "text": "It will not have any of those cycles as an induced sub graph. And it's an equivalent instance to"
  },
  {
    "start": "00:34:03,040",
    "end": "00:34:11,200",
    "text": "the grid tiling. And that basically gives you a W1 hardness of independent set on this class of graphs."
  },
  {
    "start": "00:34:13,360",
    "end": "00:34:19,600",
    "text": "So notice in this case that an independent set of size 8k squared into P plus 1 will have to"
  },
  {
    "start": "00:34:19,600",
    "end": "00:34:23,760",
    "text": "be a maximum independent set because that's how many clicks we get in the resulting graph."
  },
  {
    "start": "00:34:24,480",
    "end": "00:34:29,920",
    "text": "And that's basically the sizes that we will be working with, more or less up to some modifications."
  },
  {
    "start": "00:34:30,400",
    "end": "00:34:38,080",
    "text": "But this will allow us to basically conclude that both sliding and jumping are hard on this class of"
  },
  {
    "start": "00:34:38,080",
    "end": "00:34:48,480",
    "text": "graphs. So how do we use this for showing hardness of token sliding and token jumping? And let's"
  },
  {
    "start": "00:34:48,480",
    "end": "00:34:54,480",
    "text": "focus on token sliding for now because it's going to be the same anyway. So we have those clicks"
  },
  {
    "start": "00:34:55,040",
    "end": "00:35:02,080",
    "text": "and some edges that go between the clicks. So the first attempt would be as follows. We will add"
  },
  {
    "start": "00:35:02,800",
    "end": "00:35:08,640",
    "text": "a universal vertex to each one of the clicks and we will call this the starting set or the starting"
  },
  {
    "start": "00:35:08,640",
    "end": "00:35:14,560",
    "text": "independent set. And then we add another universal vertex to each one of the clicks and call this"
  },
  {
    "start": "00:35:14,640",
    "end": "00:35:20,400",
    "text": "the target independent set. And now basically we have our instance of token sliding. We want to"
  },
  {
    "start": "00:35:20,400",
    "end": "00:35:30,160",
    "text": "slide everybody in S down to T. So notice that this is useful because we don't introduce any of the"
  },
  {
    "start": "00:35:30,160",
    "end": "00:35:37,680",
    "text": "forbidden cycles. So we are still fine. And if we could guarantee that all of the tokens"
  },
  {
    "start": "00:35:37,680",
    "end": "00:35:44,480",
    "text": "will be on the on the clicks simultaneously, then this will imply an independent set in the"
  },
  {
    "start": "00:35:44,480",
    "end": "00:35:50,800",
    "text": "original graph, which concludes our proof. But unfortunately in this case, we definitely cannot"
  },
  {
    "start": "00:35:50,800",
    "end": "00:35:58,640",
    "text": "conclude that because each rent token can slide independently here and then here and then the"
  },
  {
    "start": "00:35:58,640",
    "end": "00:36:05,040",
    "text": "next one can follow, etc, etc, etc. So you need some way of forbidden, are forbidding"
  },
  {
    "start": "00:36:06,000",
    "end": "00:36:14,400",
    "text": "the tokens to behave freely. We want to make sure that they will all be inside the clicks simultaneously"
  },
  {
    "start": "00:36:14,400",
    "end": "00:36:19,760",
    "text": "and we will be done. And notice that we're going to have 8k squared and 2p plus 1 tokens, right?"
  },
  {
    "start": "00:36:19,760",
    "end": "00:36:27,200",
    "text": "1 for each click and 2 universal vertices for each click. So how do we fix this time of 1080"
  },
  {
    "start": "00:36:27,760",
    "end": "00:36:35,760",
    "text": "issue? Well, here's how we can do it. So instead of simply adding universal vertices,"
  },
  {
    "start": "00:36:36,560",
    "end": "00:36:42,240",
    "text": "we're also going to add an edge between every two universal vertices of a click. And then we're"
  },
  {
    "start": "00:36:42,240",
    "end": "00:36:49,600",
    "text": "going to add something that we call a switch. And in this case, it's a simple edge. And the red token"
  },
  {
    "start": "00:36:50,160",
    "end": "00:36:57,440",
    "text": "needs to go to the blue position. Right? So now we have one extra token inside our graph."
  },
  {
    "start": "00:36:57,440",
    "end": "00:37:08,400",
    "text": "But now notice what happens. If any red token wants to come to the blue position, then this red token"
  },
  {
    "start": "00:37:08,400",
    "end": "00:37:14,720",
    "text": "needs to be moved to this position before. And if you move that token up to the blue position,"
  },
  {
    "start": "00:37:14,800",
    "end": "00:37:20,320",
    "text": "then you can no longer have any of the red tokens on the universal vertices, which means that they"
  },
  {
    "start": "00:37:20,320",
    "end": "00:37:27,360",
    "text": "will all have to be simultaneously inside the clicks. And now we get the behavior that we want."
  },
  {
    "start": "00:37:29,360",
    "end": "00:37:34,560",
    "text": "So now we can guarantee that if there is a sequence that takes the red tokens to the blue position,"
  },
  {
    "start": "00:37:36,000",
    "end": "00:37:43,040",
    "text": "then somewhere along that sequence, the tokens are all going to be within the clicks. Unfortunately,"
  },
  {
    "start": "00:37:43,040",
    "end": "00:37:48,720",
    "text": "what happened here is we might have introduced some of the forbidden cycles. We can no longer"
  },
  {
    "start": "00:37:48,720",
    "end": "00:37:56,960",
    "text": "guarantee that this is C4 up to CP3. So what you can do in this case to solve this problem,"
  },
  {
    "start": "00:37:56,960",
    "end": "00:38:02,720",
    "text": "and I'm not going to go into the details, but the intuition should be pretty clear, is that you can"
  },
  {
    "start": "00:38:02,720",
    "end": "00:38:09,280",
    "text": "subdivide those edges, make them long enough so that you don't introduce any forbidden cycles,"
  },
  {
    "start": "00:38:09,360",
    "end": "00:38:13,040",
    "text": "and add appropriate tokens inside of them to get the same behavior."
  },
  {
    "start": "00:38:15,200",
    "end": "00:38:19,760",
    "text": "Because notice that the number of such edges is bounded by a function of K,"
  },
  {
    "start": "00:38:20,640",
    "end": "00:38:24,400",
    "text": "by a function of yes K and P. This case."
  },
  {
    "start": "00:38:26,240",
    "end": "00:38:33,040",
    "text": "Right, so you can make these edges subdivide them as many times as needed, add as many tokens"
  },
  {
    "start": "00:38:33,040",
    "end": "00:38:37,920",
    "text": "as needed to maintain all the properties that we need, and to maintain that we're going from one"
  },
  {
    "start": "00:38:37,920",
    "end": "00:38:44,720",
    "text": "maximum independent set to the other, which will give you W1 hardness for both token sliding as well"
  },
  {
    "start": "00:38:44,720",
    "end": "00:38:55,200",
    "text": "as token jumping. All right, questions?"
  },
  {
    "start": "00:38:55,360",
    "end": "00:39:10,720",
    "text": "No questions? All right, so let's keep going."
  },
  {
    "start": "00:39:13,680",
    "end": "00:39:17,600",
    "text": "So now I'm going to talk about some positive result."
  },
  {
    "start": "00:39:18,000",
    "end": "00:39:23,040",
    "text": "So the result that I'm going to talk about is this one here."
  },
  {
    "start": "00:39:23,920",
    "end": "00:39:33,120",
    "text": "Right, so I'm going to show you that on C3, C4 free graphs, token jumping is actually FPD and has"
  },
  {
    "start": "00:39:33,120",
    "end": "00:39:38,400",
    "text": "a quadratic kernel, but again, what we will show is a stronger result."
  },
  {
    "start": "00:39:39,360",
    "end": "00:39:48,880",
    "text": "So what we will show is the following theorem. What we will show is can be summarized as follows."
  },
  {
    "start": "00:39:48,880",
    "end": "00:39:55,440",
    "text": "So if you look at any graph or at any instance of the token jumping problem."
  },
  {
    "start": "00:39:55,440",
    "end": "00:40:00,800",
    "text": "So remember, an instance of token jumping has the input graph, the starting set, the target set,"
  },
  {
    "start": "00:40:00,800",
    "end": "00:40:09,920",
    "text": "and K as the number of tokens. So let me try and draw something here. So if you look at"
  },
  {
    "start": "00:40:11,040",
    "end": "00:40:16,160",
    "text": "your graph, you can kind of decompose it into something which is more or less as follows."
  },
  {
    "start": "00:40:17,120",
    "end": "00:40:21,760",
    "text": "So you have S, you have T, the intersection need not be empty,"
  },
  {
    "start": "00:40:23,280",
    "end": "00:40:26,640",
    "text": "and then you have the neighborhood of S union T,"
  },
  {
    "start": "00:40:26,800",
    "end": "00:40:30,480",
    "text": "and then you have the rest of the graph."
  },
  {
    "start": "00:40:33,040",
    "end": "00:40:39,360",
    "text": "So we're going to call the rest of the graph H, and we're going to call the close neighborhood"
  },
  {
    "start": "00:40:39,360",
    "end": "00:40:46,320",
    "text": "of S union D, or if you will, this yellow part here, we call that J."
  },
  {
    "start": "00:40:47,120",
    "end": "00:40:52,080",
    "text": "Right, so we can think of our problem of our graph as being decomposed into those two areas."
  },
  {
    "start": "00:40:52,640",
    "end": "00:40:58,560",
    "text": "H and J. Okay, so the theorem states the following."
  },
  {
    "start": "00:40:59,520",
    "end": "00:41:06,480",
    "text": "If H is epsilon sparse, where epsilon sparse means that the number of edges is at most"
  },
  {
    "start": "00:41:06,480",
    "end": "00:41:15,680",
    "text": "n squared minus epsilon, positive epsilon. So if H is epsilon sparse, and J is C3C for free,"
  },
  {
    "start": "00:41:16,480",
    "end": "00:41:24,400",
    "text": "then the problem admits a kernel, which is that big, K squared plus K into 1 plus 1 over epsilon."
  },
  {
    "start": "00:41:25,280",
    "end": "00:41:34,640",
    "text": "So notice now that we only need that H is epsilon sparse, and we only require C3C for"
  },
  {
    "start": "00:41:34,720",
    "end": "00:41:41,360",
    "text": "freeness inside J, which is S union T close neighborhood of S union T."
  },
  {
    "start": "00:41:45,120",
    "end": "00:41:50,320",
    "text": "And this idea is actually is not a new idea. So this idea is,"
  },
  {
    "start": "00:41:51,600",
    "end": "00:41:55,920",
    "text": "okay, I had the drawing here, I should have used it. So the idea comes from,"
  },
  {
    "start": "00:41:55,920",
    "end": "00:42:02,160",
    "text": "from has been used before, and it's what we call the buffer technique for the token jumping problem."
  },
  {
    "start": "00:42:02,240",
    "end": "00:42:08,880",
    "text": "And the intuition behind the buffer technique is very simple. So if I have S union T, but somewhere"
  },
  {
    "start": "00:42:09,760",
    "end": "00:42:15,120",
    "text": "in the graph, which is not in the close neighborhood of S union T, I have a case sized"
  },
  {
    "start": "00:42:15,120",
    "end": "00:42:21,360",
    "text": "independent set, then you are done. Right, if I have a case sized independent set in H,"
  },
  {
    "start": "00:42:22,880",
    "end": "00:42:28,720",
    "text": "then you're done. You can basically take all the tokens on S, jump them into those"
  },
  {
    "start": "00:42:29,360",
    "end": "00:42:32,960",
    "text": "independent yellow vertices in H, and then jump them back to T."
  },
  {
    "start": "00:42:34,480",
    "end": "00:42:39,120",
    "text": "So in some sense, when H has a large independent set, that's the easy case."
  },
  {
    "start": "00:42:40,880",
    "end": "00:42:44,960",
    "text": "Right, you're done. If you can find a large enough independent set in H, you're done."
  },
  {
    "start": "00:42:46,240",
    "end": "00:42:50,960",
    "text": "And that's what we call the buffer technique, because it's been also used to show that the problem"
  },
  {
    "start": "00:42:50,960",
    "end": "00:42:58,160",
    "text": "is FBT on planar graphs, for example, or K3J free graphs. So graphs without large bi-clips."
  },
  {
    "start": "00:42:59,280",
    "end": "00:43:12,720",
    "text": "So it's a well-known technique. All right. So what do we show? So we're going to use the buffer technique,"
  },
  {
    "start": "00:43:12,720",
    "end": "00:43:20,480",
    "text": "and we're going to combine it with something else. So we show that you have a yes instance"
  },
  {
    "start": "00:43:21,440",
    "end": "00:43:29,760",
    "text": "whenever one of those two conditions is true. The first condition is that H is epsilon sparse and"
  },
  {
    "start": "00:43:29,760",
    "end": "00:43:38,320",
    "text": "contains more than this many vertices. And this is relatively easy. When you contain this"
  },
  {
    "start": "00:43:38,320",
    "end": "00:43:43,680",
    "text": "many vertices and you add epsilon sparse, then you will have a case size independent set."
  },
  {
    "start": "00:43:43,680",
    "end": "00:43:49,440",
    "text": "And that's basically the buffer technique. When H is epsilon sparse and has that many vertices"
  },
  {
    "start": "00:43:49,440",
    "end": "00:43:54,000",
    "text": "or more, then H is guaranteed to have an independent set of sparse and you're done."
  },
  {
    "start": "00:43:55,520",
    "end": "00:44:02,000",
    "text": "So now you are stuck with what happens inside J, or the closed neighborhood of S-Union T."
  },
  {
    "start": "00:44:02,560",
    "end": "00:44:09,920",
    "text": "And it turns out there, if you have C3C for freeness, the only thing you need on top of that,"
  },
  {
    "start": "00:44:09,920",
    "end": "00:44:14,080",
    "text": "to guarantee a yes instance, is a vertex of degree at least 3K."
  },
  {
    "start": "00:44:14,560",
    "end": "00:44:24,880",
    "text": "So if you have C3C for freeness inside J, and the vertex of degree 3K, then again you get a yes instance."
  },
  {
    "start": "00:44:24,880",
    "end": "00:44:34,880",
    "text": "So let me prove those two statements separately, because they will be basically what we need for the"
  },
  {
    "start": "00:44:34,880",
    "end": "00:44:44,000",
    "text": "final theorem for the final theorem. So the first lemma, as I told you, if H is epsilon sparse and"
  },
  {
    "start": "00:44:44,000",
    "end": "00:44:49,600",
    "text": "has more than this many vertices, then it's a yes instance, because you have a case size"
  },
  {
    "start": "00:44:49,600",
    "end": "00:44:55,440",
    "text": "independent set in H. The idea of this proof is simple. It's a counting argument."
  },
  {
    "start": "00:44:56,160",
    "end": "00:45:01,360",
    "text": "And what you need to do basically first is to show that H must contain a vertex of degree"
  },
  {
    "start": "00:45:01,360",
    "end": "00:45:07,920",
    "text": "less than and over K. And then basically you apply the standard greedy packing algorithm for"
  },
  {
    "start": "00:45:07,920",
    "end": "00:45:13,600",
    "text": "constructing an independent set of size K. And the reason you show that the way you show that H"
  },
  {
    "start": "00:45:13,600",
    "end": "00:45:19,920",
    "text": "has a vertex of degree less than and over K is, again, standard counting argument and the"
  },
  {
    "start": "00:45:19,920",
    "end": "00:45:26,480",
    "text": "hand-shaking lemma. So if the minimum degree in H was at least n over K, then the number of edges"
  },
  {
    "start": "00:45:26,480",
    "end": "00:45:34,880",
    "text": "would be at least n squared over 2K, which will only happen in an epsilon sparse graph when n is"
  },
  {
    "start": "00:45:34,880",
    "end": "00:45:43,120",
    "text": "less than or equal 2K to the power 1 over S. And the rest of the proof is basically an induction on K."
  },
  {
    "start": "00:45:45,200",
    "end": "00:45:50,160",
    "text": "Okay, and so that shows you that when you do have an epsilon sparse graph with more than"
  },
  {
    "start": "00:45:50,800",
    "end": "00:46:00,480",
    "text": "this many vertices, then we have a yes instance. All right, so how about the second part of the claim?"
  },
  {
    "start": "00:46:00,480",
    "end": "00:46:07,920",
    "text": "So now what happens if we have a C3 C4 free J that has a vertex of degree 3K? Well, let's see what"
  },
  {
    "start": "00:46:07,920",
    "end": "00:46:16,720",
    "text": "happens. So if we have a vertex of degree 3K and I'm going to circle it here in yellow. So how can"
  },
  {
    "start": "00:46:16,720",
    "end": "00:46:22,960",
    "text": "the neighborhood of that vertex look? Well, we know that J is C3 free. So the blue edges cannot"
  },
  {
    "start": "00:46:22,960",
    "end": "00:46:28,960",
    "text": "exist, which means that the neighborhood of the yellow vertex is an independent set inside J,"
  },
  {
    "start": "00:46:30,800",
    "end": "00:46:37,680",
    "text": "not in the whole graph. Well, in fact, in the whole well known because we're only talking about J"
  },
  {
    "start": "00:46:37,680",
    "end": "00:46:44,960",
    "text": "as a subgratio. Right, so the blue edges cannot exist because otherwise we will get a C3 inside J."
  },
  {
    "start": "00:46:46,960",
    "end": "00:46:57,600",
    "text": "All right, so now let's look at the other vertices in S union T. The other, the second observation"
  },
  {
    "start": "00:46:57,600",
    "end": "00:47:04,080",
    "text": "that you need is that any vertex other than the yellow vertex can have at most one neighbor in"
  },
  {
    "start": "00:47:04,080",
    "end": "00:47:11,600",
    "text": "common with the yellow vertex. Because if you do have two neighbors in common, then you will get a C4."
  },
  {
    "start": "00:47:11,680",
    "end": "00:47:21,760",
    "text": "So now what happens if we have three k vertices in the neighborhood of the yellow vertex? Well,"
  },
  {
    "start": "00:47:22,880",
    "end": "00:47:30,320",
    "text": "at most two k of them can be connected to some vertex in S union T and you will get at least k"
  },
  {
    "start": "00:47:30,320",
    "end": "00:47:40,240",
    "text": "of them, some k of them here that are only connected to the yellow vertex. And so now basically,"
  },
  {
    "start": "00:47:40,240",
    "end": "00:47:44,720",
    "text": "instead of using a buffer inside H, we have just found a buffer inside J."
  },
  {
    "start": "00:47:46,480",
    "end": "00:47:52,640",
    "text": "And we can use the same strategy. We can jump all the tokens here, starting of course by the yellow"
  },
  {
    "start": "00:47:52,640",
    "end": "00:47:56,080",
    "text": "token and then jump them to where they need to go."
  },
  {
    "start": "00:47:56,160",
    "end": "00:48:13,440",
    "text": "So now combining those two observations together, if you will, we get the following theorem."
  },
  {
    "start": "00:48:13,440",
    "end": "00:48:20,320",
    "text": "So if H is alpha sparse and J is C3, C4, free, then the problem admits a kernel on this"
  },
  {
    "start": "00:48:20,320",
    "end": "00:48:26,400",
    "text": "maneuver to C's. And it's basically a simple application of the previous two lemmas. If we have"
  },
  {
    "start": "00:48:26,400",
    "end": "00:48:32,480",
    "text": "more than this maneuver to C's in H, it's a trivial yes instance. If J has a vertex of"
  },
  {
    "start": "00:48:32,480",
    "end": "00:48:38,800",
    "text": "degree 3k or more, it's trivial yes instance. And now you combine all of this together. We know that"
  },
  {
    "start": "00:48:38,800",
    "end": "00:48:45,280",
    "text": "S union T is of size at most 2k. We know that the neighborhood of S union T is of size at most"
  },
  {
    "start": "00:48:45,280",
    "end": "00:48:52,160",
    "text": "2k times 3k, which is roughly 6k squared. And now we know that the rest of the graph has at most"
  },
  {
    "start": "00:48:52,160",
    "end": "00:48:58,160",
    "text": "that maneuver to C's. So basically, you sum up those numbers and you get this bound."
  },
  {
    "start": "00:49:06,480",
    "end": "00:49:12,240",
    "text": "All right. So how does this theorem imply the result that I promised you to start with?"
  },
  {
    "start": "00:49:15,440",
    "end": "00:49:22,000",
    "text": "So that token jumping and token sliding admit kernel with order k squared vertices."
  },
  {
    "start": "00:49:23,360",
    "end": "00:49:29,440",
    "text": "I mean, I mean, it also holds for bipartite C4 free graphs, right? Obviously because they are C3C4 free."
  },
  {
    "start": "00:49:30,240",
    "end": "00:49:37,840",
    "text": "So how do you get the kernel? Well, we know that J cannot contain more than 6k squared minus 2"
  },
  {
    "start": "00:49:37,840",
    "end": "00:49:48,640",
    "text": "k vertices. And we know from a theorem from another paper that C3 free graphs with k squared"
  },
  {
    "start": "00:49:48,640",
    "end": "00:49:54,880",
    "text": "over log k vertices must have an independent set of size at least k. And now we know that if H"
  },
  {
    "start": "00:49:54,880",
    "end": "00:49:58,640",
    "text": "contains more than this maneuver to C's, then we will get the yes instance as well."
  },
  {
    "start": "00:50:00,880",
    "end": "00:50:06,640",
    "text": "Right. So it becomes an immediate consequence of the previous theorem. But the previous theorem"
  },
  {
    "start": "00:50:06,640",
    "end": "00:50:12,560",
    "text": "is even more general than this corollary. So this corollary does not really use the full power of this theorem."
  },
  {
    "start": "00:50:16,400",
    "end": "00:50:23,200",
    "text": "All right. That's it. I think I'm fine. If you have questions, I will take them now."
  },
  {
    "start": "00:50:23,200",
    "end": "00:50:35,120",
    "text": "So it was 55 minutes, right? For the talk. I did not go under the talk."
  },
  {
    "start": "00:50:35,120",
    "end": "00:50:39,120",
    "text": "It's fine. We usually allow plus minus 10 minutes. That's all right."
  },
  {
    "start": "00:50:42,400",
    "end": "00:50:45,920",
    "text": "So I have a question about token sliding. Yes."
  },
  {
    "start": "00:50:46,880",
    "end": "00:50:54,320",
    "text": "So how crucial what happens if one does not restrict the independent sets during the configuration"
  },
  {
    "start": "00:50:55,440",
    "end": "00:51:02,560",
    "text": "to be not of the same size? Is that is that very critical for the difficulty or the easiness of the problem?"
  },
  {
    "start": "00:51:03,680",
    "end": "00:51:08,560",
    "text": "Well, you have to be careful how you define that because in token sliding,"
  },
  {
    "start": "00:51:09,520",
    "end": "00:51:15,680",
    "text": "tokens cannot leave the graph. That's correct. But the independent set sequence"
  },
  {
    "start": "00:51:15,680",
    "end": "00:51:18,320",
    "text": "all the independent sets have to be the same size, right?"
  },
  {
    "start": "00:51:18,320",
    "end": "00:51:24,080",
    "text": "Or if not some token disappeared at some point and I'm not sure how it disappeared."
  },
  {
    "start": "00:51:26,400",
    "end": "00:51:31,680",
    "text": "Right. Because you start with something of size K and you're going to something of size K,"
  },
  {
    "start": "00:51:31,680",
    "end": "00:51:40,080",
    "text": "you cannot leave the graph unless you define it in some way. So you will remain of size K throughout."
  },
  {
    "start": "00:51:41,040",
    "end": "00:51:46,080",
    "text": "But you can become slightly larger in K. But where does the new token come from?"
  },
  {
    "start": "00:51:49,040",
    "end": "00:51:55,120",
    "text": "So there is a third rule that I did not tell you about which is called token addition and remove."
  },
  {
    "start": "00:51:56,960",
    "end": "00:52:03,520",
    "text": "Under that rule, we actually allow you to remove vertices and adversities as long as you remain"
  },
  {
    "start": "00:52:03,600",
    "end": "00:52:12,240",
    "text": "an independent set of size at least K. Does that answer your question?"
  },
  {
    "start": "00:52:12,240",
    "end": "00:52:19,200",
    "text": "Yeah, yeah, yeah, yeah. But in fact, it was shown that it was shown that"
  },
  {
    "start": "00:52:20,720",
    "end": "00:52:23,680",
    "text": "so addition and removal is equivalent to token jumping."
  },
  {
    "start": "00:52:25,920",
    "end": "00:52:30,560",
    "text": "It doesn't it never makes sense to add more tokens to your graph if you don't need them."
  },
  {
    "start": "00:52:34,400",
    "end": "00:52:37,360",
    "text": "You're only making your life harder into it and be speaking."
  },
  {
    "start": "00:52:41,120",
    "end": "00:52:43,840",
    "text": "So the other question that I had is I mean I heard I"
  },
  {
    "start": "00:52:46,720",
    "end": "00:52:54,640",
    "text": "so is it possible to view this whole problem on an exponential size graph where every vertex"
  },
  {
    "start": "00:52:55,280",
    "end": "00:52:59,680",
    "text": "corresponds to a independent set in the original graph."
  },
  {
    "start": "00:53:00,640",
    "end": "00:53:06,640",
    "text": "And then you have edges between two vertices if there is an edge between two vertices of the"
  },
  {
    "start": "00:53:06,640",
    "end": "00:53:13,280",
    "text": "independent set. And now you are doing a reachability question. Is that a meaningful way to think about"
  },
  {
    "start": "00:53:13,280",
    "end": "00:53:20,240",
    "text": "this? But that's exactly what we're doing. But so the way you define your adjacency, I think. So you"
  },
  {
    "start": "00:53:20,240",
    "end": "00:53:25,760",
    "text": "mean you define you make two independent sets adjacent if one can be reached from the other via a"
  },
  {
    "start": "00:53:25,760",
    "end": "00:53:30,480",
    "text": "single slide or a single joint. Exactly. Yeah, one edge here. There is one pair you and me,"
  },
  {
    "start": "00:53:30,480",
    "end": "00:53:35,440",
    "text": "which is adjacent. But that's but that's exactly what we're doing. Okay, okay. Yeah."
  },
  {
    "start": "00:53:36,000",
    "end": "00:53:42,560",
    "text": "Right? I mean if you because we're looking at algorithms here, we kind of forget the structural"
  },
  {
    "start": "00:53:42,560",
    "end": "00:53:47,520",
    "text": "picture behind it. But this algorithm is finding a path in this graph that you're describing."
  },
  {
    "start": "00:53:48,720",
    "end": "00:53:54,800",
    "text": "Yeah, yeah, that's it. And what we're saying is you can do it in FBT time or not depending on the"
  },
  {
    "start": "00:53:54,800",
    "end": "00:54:13,360",
    "text": "problem we're talking about. Hi Amir. Hi Amir. Hi. Hi. Hi. Yeah. I'm good. So I had a question. So"
  },
  {
    "start": "00:54:14,160",
    "end": "00:54:21,280",
    "text": "do problems remain equally hard if we bound the if we have a restriction on the number of times,"
  },
  {
    "start": "00:54:21,280",
    "end": "00:54:30,720",
    "text": "we can move the token to a particular vertex. The number of times you can move a token to a"
  },
  {
    "start": "00:54:30,720",
    "end": "00:54:36,400",
    "text": "particular vertex. Like, there's a lot of times the tokens can be moved to a vertex."
  },
  {
    "start": "00:54:38,400",
    "end": "00:54:45,040",
    "text": "Well, that's definitely going to change the complexity in at least intuitively speaking, right? Because"
  },
  {
    "start": "00:54:46,000",
    "end": "00:54:51,040",
    "text": "now you're saying maybe it will, if you're bounding that by a constant, then you might be saying that"
  },
  {
    "start": "00:54:51,600",
    "end": "00:54:58,640",
    "text": "I'm not allowing exponentially large sequences anymore. But in terms of exactly how the complexity"
  },
  {
    "start": "00:54:58,640",
    "end": "00:55:06,480",
    "text": "changes, I don't have answers. I think it's a very nice question to pose. Even in terms of"
  },
  {
    "start": "00:55:06,480",
    "end": "00:55:11,200",
    "text": "a non-parameterized complexity standard complexity, I think that that would be a very interesting"
  },
  {
    "start": "00:55:11,200",
    "end": "00:55:17,360",
    "text": "question because because it will definitely affect the behavior. I'm not sure exactly how yet."
  },
  {
    "start": "00:55:18,320",
    "end": "00:55:22,640",
    "text": "I don't know of any results that ask this particular question."
  },
  {
    "start": "00:55:23,760",
    "end": "00:55:30,320",
    "text": "Okay. So I had one more question in the W. Harnes result that you presented. So do you know"
  },
  {
    "start": "00:55:30,320",
    "end": "00:55:38,720",
    "text": "what is the length of the the length of the changes? Actually, the number of changes or flips that"
  },
  {
    "start": "00:55:38,720",
    "end": "00:55:46,880",
    "text": "you make in your independence? This is just yes. Yes. Yes. Yes. Yes. We do. So here, the number of"
  },
  {
    "start": "00:55:46,880",
    "end": "00:55:51,200",
    "text": "changes is going to be where it's basically going to be the shortest possible sequence."
  },
  {
    "start": "00:55:53,040",
    "end": "00:55:59,840",
    "text": "So it's going to be, so if you think about the simple construction, this one,"
  },
  {
    "start": "00:56:04,000",
    "end": "00:56:09,440",
    "text": "it's basically literally going to be these guys are going to move here. So H is going to cost me"
  },
  {
    "start": "00:56:09,440",
    "end": "00:56:16,000",
    "text": "one slide and then they're all going to and now this guy is going to move here and now I will"
  },
  {
    "start": "00:56:16,000",
    "end": "00:56:22,640",
    "text": "pay one slide for each one here. Now this is the simplified version of it. Once you go to the complete"
  },
  {
    "start": "00:56:22,640",
    "end": "00:56:27,680",
    "text": "version of it, you have some extra slides within the path, but you can also count those."
  },
  {
    "start": "00:56:29,440",
    "end": "00:56:37,920",
    "text": "Okay. So, but does this mean that so does this mean that at a particular vertex we are placing"
  },
  {
    "start": "00:56:38,000",
    "end": "00:56:48,320",
    "text": "the token at most once? In this case, yes. Okay. In this case, yes. Okay. So this problem should be hard"
  },
  {
    "start": "00:56:48,320",
    "end": "00:56:57,520",
    "text": "even if we bound the number of times tokens can be moved to our vertex, right? Yes. Okay."
  },
  {
    "start": "00:56:57,520",
    "end": "00:57:02,720",
    "text": "Yes. So here in this case, yes. Absolutely. Okay. Thanks."
  },
  {
    "start": "00:57:03,440",
    "end": "00:57:13,360",
    "text": "So, Akansha, I have a remark about your question. So if a vertex cannot get a token to I's,"
  },
  {
    "start": "00:57:14,000",
    "end": "00:57:18,080",
    "text": "then it somehow seems to be selecting disjoint independent sets."
  },
  {
    "start": "00:57:20,800",
    "end": "00:57:25,760",
    "text": "A sequence of them and that may have some bearing on coloring. Just a top level top."
  },
  {
    "start": "00:57:25,920",
    "end": "00:57:35,520",
    "text": "Okay. So actually for the list, the W hardness case that I'm going to present it, it is exactly"
  },
  {
    "start": "00:57:35,520",
    "end": "00:57:41,360",
    "text": "the case, right? So we are not allowed to move the token like twice on the same vertex."
  },
  {
    "start": "00:57:43,280",
    "end": "00:57:49,360",
    "text": "Yeah. So I didn't get your point of being so getting this disjoint independence, it's actually"
  },
  {
    "start": "00:57:50,080",
    "end": "00:57:56,000",
    "text": "because if you think of it from the way I thought about it, right, that you are actually trying to find"
  },
  {
    "start": "00:57:56,000",
    "end": "00:58:01,680",
    "text": "a path in a large graph where every vertex corresponds to an independent set and you move from one"
  },
  {
    "start": "00:58:01,680",
    "end": "00:58:10,960",
    "text": "independent set to another. But we can only move from one independent set to the other if the change"
  },
  {
    "start": "00:58:10,960",
    "end": "00:58:24,400",
    "text": "is like in case of tokens sliding, it's one probably. Yeah. So it looks to be that you're asking for"
  },
  {
    "start": "00:58:26,160",
    "end": "00:58:32,560",
    "text": "a collection of independent sets which are vertex disjoint. If the token sequence of independence"
  },
  {
    "start": "00:58:32,560",
    "end": "00:58:39,600",
    "text": "sets which are vertex disjoint. So if I may, I think I think Akansha's question would be more"
  },
  {
    "start": "00:58:39,600",
    "end": "00:58:46,080",
    "text": "relevant in a place where we don't have a monotone sequence, meaning a sequence. So we need a"
  },
  {
    "start": "00:58:46,080",
    "end": "00:58:51,920",
    "text": "version of the problem or some cases of the problem where a vertex has to be visited multiple times"
  },
  {
    "start": "00:58:53,520",
    "end": "00:58:59,040",
    "text": "to find solutions. And that is known to be the case for some versions or some statements of the"
  },
  {
    "start": "00:58:59,040",
    "end": "00:59:05,760",
    "text": "problem. And in fact, Akansha, so this was the crucial difference between piece-based completeness"
  },
  {
    "start": "00:59:05,760",
    "end": "00:59:12,480",
    "text": "and NP completeness of sliding versus jumping in bipartite graphs. So it was because we were"
  },
  {
    "start": "00:59:12,480",
    "end": "00:59:19,760",
    "text": "able to show that no vertex will be visited more than once. Okay. And the other problem. So that's"
  },
  {
    "start": "00:59:19,760",
    "end": "00:59:24,560",
    "text": "why it's definitely an interesting question to pose, but you have to be careful in what context you"
  },
  {
    "start": "00:59:24,560",
    "end": "00:59:35,520",
    "text": "pose it. Great. I don't know if that kind of settles, answers your question. Yes, yes, it does."
  },
  {
    "start": "00:59:36,080",
    "end": "00:59:39,120",
    "text": "All right. Thanks. You're welcome."
  },
  {
    "start": "00:59:46,960",
    "end": "00:59:54,320",
    "text": "Any more questions?"
  },
  {
    "start": "01:00:05,760",
    "end": "01:00:26,480",
    "text": "I guess not. Yeah, I don't think that I know more questions. I will just once again announce the"
  },
  {
    "start": "01:00:26,480",
    "end": "01:00:32,320",
    "text": "parameterized and go to the 301 workshop, which is going to happen in December in the link has been"
  },
  {
    "start": "01:00:32,400",
    "end": "01:00:38,560",
    "text": "posted once again in the chat. Some advanced topics in parameterized complexity will be discussed."
  },
  {
    "start": "01:00:38,560",
    "end": "01:00:46,720",
    "text": "Those interested can have a look and register for it. And yeah, if there are some more questions,"
  },
  {
    "start": "01:00:46,720",
    "end": "01:00:54,320",
    "text": "please ask away."
  },
  {
    "start": "01:01:02,320",
    "end": "01:01:20,480",
    "text": "So anyone can register for the school? Yes, here's anyone can."
  },
  {
    "start": "01:01:20,480",
    "end": "01:01:27,200",
    "text": "Yeah, it's free and it's online and yeah, it's open to everyone."
  },
  {
    "start": "01:01:27,840",
    "end": "01:01:32,000",
    "text": "Awesome. So I can share it with my students as well. Of course, of course, please do. Yeah, that's"
  },
  {
    "start": "01:01:32,000",
    "end": "01:01:38,960",
    "text": "a good one. And we assume some basic understanding of parameterized algorithms, but we have already shared"
  },
  {
    "start": "01:01:38,960",
    "end": "01:01:45,760",
    "text": "a link on the page where students can go and go through some previous lectures in parameterized"
  },
  {
    "start": "01:01:45,760",
    "end": "01:01:50,320",
    "text": "algorithms if they wish to just brace up or revise stuff."
  },
  {
    "start": "01:01:57,680",
    "end": "01:02:05,520",
    "text": "All right, so I guess, okay, I don't think there are any more questions. So I think it's a good time"
  },
  {
    "start": "01:02:05,520",
    "end": "01:02:12,640",
    "text": "to wrap up. So thank you once again for the summit for agreeing to give the talk. It was really nice"
  },
  {
    "start": "01:02:12,640",
    "end": "01:02:17,600",
    "text": "to have you and it was really good to have something different than what we usually hear in every"
  },
  {
    "start": "01:02:17,600",
    "end": "01:02:23,520",
    "text": "parameterized complexity talk, at least most of them. So and yeah, these are really interesting"
  },
  {
    "start": "01:02:23,520",
    "end": "01:02:29,760",
    "text": "problems. Do you think of one? And thank you to the audience for being with us. And that's it for"
  },
  {
    "start": "01:02:29,760",
    "end": "01:02:35,040",
    "text": "today's wrap up. See you all next week. Thank you. Bye. Thank you. Bye."
  }
]